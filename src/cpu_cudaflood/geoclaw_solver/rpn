amrlib_source/quick_sort1.f:C by a colleague at Penn State (a long time ago - Fortran 66, please
amrlib_source/quick_sort1.f:C Sept. 1970, pp 563-567; also you younger folks who weren't born at
amrlib_source/quick_sort1.f:C pp 321-322, Algorithm 64). Note that the following algorithm sorts
amrlib_source/quick_sort1.f:C   IS A(ORD(I)),I=1,2,...,N; DESCENDING ORDER A IS A(ORD(N-I+1)),
amrlib_source/quick_sort1.f:C     ACM QUICKSORT - ALGORITHM #402 - IMPLEMENTED IN FORTRAN 66 BY
amrlib_source/quick_sort1.f:      IMPLICIT INTEGER (A-Z)
amrlib_source/quick_sort1.f:    5 IF (U-L.LE.1) GO TO 15
amrlib_source/quick_sort1.f:    7 P=Q-1
amrlib_source/quick_sort1.f:    8 Q=Q-1
amrlib_source/quick_sort1.f:      P=P-1
amrlib_source/quick_sort1.f:      IF (U-Q.LE.P-L) GO TO 16
amrlib_source/quick_sort1.f:      U1=P-1
amrlib_source/quick_sort1.f:      U=P-1
amrlib_source/quick_sort1.f:      NDEEP=NDEEP-1
amrlib_source/amr_module.f90:!! **rnode(cornxlo, 3)** stores x-coordinate of left border of grid 3.
amrlib_source/amr_module.f90:    !! - listbc(1,ispot) stores LOCAL (RALATIVE to left boundary of grid
amrlib_source/amr_module.f90:    !! - listbc(2,ispot) stores LOCAL (RALATIVE to left boundary of grid
amrlib_source/amr_module.f90:    !! - listbc(3,ispot) stores side number, which indicates which side 
amrlib_source/amr_module.f90:    !! - listbc(4,ispot) stores grid number of the finer grid that borders
amrlib_source/amr_module.f90:    !! - listbc(5,ispot) stores the position of this segment with respect to 
amrlib_source/amr_module.f90:    !! to be used in conservation fixup near coarse-fine grid intersections.
amrlib_source/amr_module.f90:    !! From node(ffluxptr,mptr) to node(ffluxptr,mptr)+lenbc-1, 
amrlib_source/amr_module.f90:    !! From node(ffluxptr,mptr)+lenbc to node(ffluxptr,mptr)+2*lenbc-1,
amrlib_source/amr_module.f90:    !> domain flags, indexed within level-of-this-grid level index space
amrlib_source/amr_module.f90:    !> x-coordinate of the left border of this grid
amrlib_source/amr_module.f90:    !> y-coordinate of the lower border of this grid
amrlib_source/amr_module.f90:    !> x-coordinate of the right border of this grid
amrlib_source/amr_module.f90:    !> y-coordinate of the upper border of this grid
amrlib_source/amr_module.f90:    integer, parameter :: gridNbor = 1 !use 1st col, 2nd col is nextfree - the link
amrlib_source/amr_module.f90:    real(kind=8), parameter :: UNSET = -1.0
amrlib_source/amr_module.f90:                rprint,     & !  regridding -  summary of new grids
amrlib_source/regions_module.f90:            write(parmunit,*) '--------------------------------------------'
amrlib_source/regions_module.f90:            write(parmunit,*) '-----------'
amrlib_source/opendatafile.f:c     commentlines = -1
amrlib_source/opendatafile.f:      commentlines = -1
amrlib_source/opendatafile.f:      do commentlines=-1,1000
amrlib_source/check4nans.f90:    real(kind=8), intent(in) :: t, q(meqn,1-mbc:mx+mbc,1-mbc:my+mbc)
amrlib_source/check4nans.f90:    do i=1-mbc,mx+mbc
amrlib_source/check4nans.f90:        do j=1-mbc,my+mbc
amrlib_source/check4nans.f90:                    print *, 'SOLUTION ERROR --- ABORTING CALCULATION'
CMakeLists.txt:# -- fortran library
CMakeLists.txt:# -- add library
CMakeLists.txt:# -- install
fc2d_geoclaw.cpp:Copyright (c) 2012-2022 Carsten Burstedde, Donna Calhoun, Yu-Hsuan Shih, Scott Aiton
fc2d_geoclaw.cpp:/* ----------------------------- static function defs ------------------------------- */
fc2d_geoclaw.cpp:/* --------------------------- Creating/deleting patches ---------------------------- */
fc2d_geoclaw.cpp:/* -------------------------- Clawpack solver functions ------------------------------ */
fc2d_geoclaw.cpp:    if (geoclaw_vt->setprob != NULL)
fc2d_geoclaw.cpp:        geoclaw_vt->setprob();
fc2d_geoclaw.cpp:    FCLAW_ASSERT(geoclaw_vt->qinit != NULL); /* Must initialized */
fc2d_geoclaw.cpp:    geoclaw_vt->qinit(&meqn,&mbc,&mx,&my,&xlower,&ylower,&dx,&dy,q,
fc2d_geoclaw.cpp:    FCLAW_ASSERT(geoclaw_vt->bc2 != NULL);
fc2d_geoclaw.cpp:    int *block_mthbc = geo_opt->mthbc;
fc2d_geoclaw.cpp:            mthbc[i] = -1;
fc2d_geoclaw.cpp:      We may be imposing boundary conditions on time-interpolated data;
fc2d_geoclaw.cpp:    geoclaw_vt->bc2(&meqn,&mbc,&mx,&my,&xlower,&ylower,
fc2d_geoclaw.cpp:    FCLAW_ASSERT(geoclaw_vt->setaux != NULL);
fc2d_geoclaw.cpp:    geoclaw_vt->setaux(&mbc,&mx,&my,&xlower,&ylower,&dx,&dy,
fc2d_geoclaw.cpp:    if (geoclaw_vt->b4step2 != NULL)
fc2d_geoclaw.cpp:        geoclaw_vt->b4step2(&mbc,&mx,&my,&meqn,q,&xlower,&ylower,
fc2d_geoclaw.cpp:    FCLAW_ASSERT(geoclaw_vt->src2 != NULL);
fc2d_geoclaw.cpp:    geoclaw_vt->src2(&meqn,&mbc,&mx,&my,&xlower,&ylower,
fc2d_geoclaw.cpp:    FCLAW_ASSERT(geoclaw_vt->rpn2 != NULL);
fc2d_geoclaw.cpp:    FCLAW_ASSERT(geoclaw_vt->rpt2 != NULL);
fc2d_geoclaw.cpp:    int level = patch->level;
fc2d_geoclaw.cpp:    /* In case we need to re-take this step */
fc2d_geoclaw.cpp:    int mwaves = geoclaw_options->mwaves;
fc2d_geoclaw.cpp:    FC2D_GEOCLAW_STEP2_WRAP(&maxm, &meqn, &maux, &mbc, geoclaw_options->method,
fc2d_geoclaw.cpp:                       geoclaw_options->mthlim, &geoclaw_options->mcapa,
fc2d_geoclaw.cpp:                       geoclaw_vt->rpn2, geoclaw_vt->rpt2,
fc2d_geoclaw.cpp:    if (geoclaw_opt->src_term > 0)
fc2d_geoclaw.cpp:/* --------------------------------- Output functions ---------------------------- */
fc2d_geoclaw.cpp:    if (geo_opt->ascii_out != 0)
fc2d_geoclaw.cpp:/* ------------------------------ Regridding functions --------------------------- */
fc2d_geoclaw.cpp:    int level = patch->level;
fc2d_geoclaw.cpp:    double t = glob->curr_time;
fc2d_geoclaw.cpp:          -- level >= maximum level allowed by any region 
fc2d_geoclaw.cpp:          -- level < minimum level required by any region
fc2d_geoclaw.cpp:        Otherwise, tag_patch = -1 and we should refine using usual criteria.
fc2d_geoclaw.cpp:        /* Need maxlevel to get length speed_tolerance - hackish? */
fc2d_geoclaw.cpp:        int maxlevel = fclaw_opt->maxlevel;
fc2d_geoclaw.cpp:    double t = glob->curr_time;
fc2d_geoclaw.cpp:        int maxlevel = fclaw_opt->maxlevel;
fc2d_geoclaw.cpp:    /* Loop over four siblings (z-ordering) */
fc2d_geoclaw.cpp:    /* Loop over four siblings (z-ordering) */
fc2d_geoclaw.cpp:        int mcapa = geo_opt->mcapa;
fc2d_geoclaw.cpp:/* ------------------------- Ghost filling - patch specific ------------------------ */
fc2d_geoclaw.cpp:    /* These will be empty for non-manifolds cases */
fc2d_geoclaw.cpp:    int mcapa = geo_opt->mcapa;
fc2d_geoclaw.cpp:    int manifold = fclaw_opt->manifold;
fc2d_geoclaw.cpp:    int mcapa = geo_opt->mcapa;
fc2d_geoclaw.cpp:    int manifold = fclaw_opt->manifold;
fc2d_geoclaw.cpp:/* --------------------------- Parallel ghost patches -------------------------------- */
fc2d_geoclaw.cpp:    if (!clawpatch_options->ghost_patch_pack_aux)
fc2d_geoclaw.cpp:/* ------------------------------ Misc access functions ----------------------------- */
fc2d_geoclaw.cpp:    FC2D_GEOCLAW_SET_MODULES(&geo_opt->mwaves, 
fc2d_geoclaw.cpp:                             &geo_opt->mcapa,
fc2d_geoclaw.cpp:                             &clawpatch_opt->meqn, 
fc2d_geoclaw.cpp:                             &clawpatch_opt->maux,
fc2d_geoclaw.cpp:                             geo_opt->mthlim, 
fc2d_geoclaw.cpp:                             geo_opt->method,
fc2d_geoclaw.cpp:                             &fclaw_opt->ax, 
fc2d_geoclaw.cpp:                             &fclaw_opt->bx, 
fc2d_geoclaw.cpp:                             &fclaw_opt->ay, 
fc2d_geoclaw.cpp:                             &fclaw_opt->by);
fc2d_geoclaw.cpp:/* -------------------------- Virtual table  ---------------------------- */
fc2d_geoclaw.cpp:	   							fclaw_pointer_map_get(glob->vtables, "fc2d_geoclaw");
fc2d_geoclaw.cpp:	FCLAW_ASSERT(geoclaw_vt->is_set != 0);
fc2d_geoclaw.cpp:    geo_opt->method[6] = clawpatch_opt->maux;
fc2d_geoclaw.cpp:    if (clawpatch_opt->ghost_patch_pack_aux)
fc2d_geoclaw.cpp:        fclaw_opt->ghost_patch_pack_extra = 1;  /* Pack the bathymetry */
fc2d_geoclaw.cpp:        fclaw_opt->ghost_patch_pack_numextrafields = clawpatch_opt->maux;
fc2d_geoclaw.cpp:    fclaw_vt->problem_setup               = geoclaw_setprob;  
fc2d_geoclaw.cpp:    // fclaw_vt->after_regrid                = geoclaw_after_regrid;  /* Handle gauges */
fc2d_geoclaw.cpp:    patch_vt->setup                       = geoclaw_patch_setup;
fc2d_geoclaw.cpp:    patch_vt->initialize                  = geoclaw_qinit;
fc2d_geoclaw.cpp:    patch_vt->physical_bc                 = geoclaw_bc2;
fc2d_geoclaw.cpp:    patch_vt->single_step_update          = geoclaw_update;  /* Includes b4step2 and src2 */
fc2d_geoclaw.cpp:    fclaw_vt->output_frame                = geoclaw_output;
fc2d_geoclaw.cpp:    patch_vt->tag4refinement              = geoclaw_patch_tag4refinement;
fc2d_geoclaw.cpp:    patch_vt->tag4coarsening              = geoclaw_patch_tag4coarsening;
fc2d_geoclaw.cpp:    patch_vt->interpolate2fine            = geoclaw_interpolate2fine;
fc2d_geoclaw.cpp:    patch_vt->average2coarse              = geoclaw_average2coarse;
fc2d_geoclaw.cpp:    clawpatch_vt->fort_copy_face          = FC2D_GEOCLAW_FORT_COPY_FACE;
fc2d_geoclaw.cpp:    clawpatch_vt->fort_copy_corner        = FC2D_GEOCLAW_FORT_COPY_CORNER;
fc2d_geoclaw.cpp:    patch_vt->average_face                = geoclaw_average_face;
fc2d_geoclaw.cpp:    patch_vt->interpolate_face            = geoclaw_interpolate_face;      
fc2d_geoclaw.cpp:    patch_vt->average_corner              = geoclaw_average_corner;
fc2d_geoclaw.cpp:    patch_vt->interpolate_corner          = geoclaw_interpolate_corner;
fc2d_geoclaw.cpp:    patch_vt->remote_ghost_setup          = geoclaw_remote_ghost_setup;
fc2d_geoclaw.cpp:    clawpatch_vt->fort_local_ghost_pack   = FC2D_GEOCLAW_LOCAL_GHOST_PACK;
fc2d_geoclaw.cpp:    clawpatch_vt->local_ghost_pack_aux    = geoclaw_local_ghost_pack_aux;
fc2d_geoclaw.cpp:    clawpatch_vt->fort_compute_error_norm = FC2D_GEOCLAW_FORT_COMPUTE_ERROR_NORM;
fc2d_geoclaw.cpp:    clawpatch_vt->fort_compute_patch_area = FC2D_GEOCLAW_FORT_COMPUTE_PATCH_AREA;
fc2d_geoclaw.cpp:    clawpatch_vt->fort_conservation_check = FC2D_GEOCLAW_FORT_CONSERVATION_CHECK;
fc2d_geoclaw.cpp:    clawpatch_vt->fort_timeinterp         = FC2D_GEOCLAW_FORT_TIMEINTERP;
fc2d_geoclaw.cpp:    geoclaw_vt->setprob          = NULL;                   
fc2d_geoclaw.cpp:    geoclaw_vt->setaux           = FC2D_GEOCLAW_SETAUX;
fc2d_geoclaw.cpp:    geoclaw_vt->qinit            = FC2D_GEOCLAW_QINIT;
fc2d_geoclaw.cpp:    geoclaw_vt->bc2              = FC2D_GEOCLAW_BC2;
fc2d_geoclaw.cpp:    geoclaw_vt->b4step2          = FC2D_GEOCLAW_B4STEP2;
fc2d_geoclaw.cpp:    geoclaw_vt->src2             = FC2D_GEOCLAW_SRC2;
fc2d_geoclaw.cpp:    geoclaw_vt->rpn2             = FC2D_GEOCLAW_RPN2;
fc2d_geoclaw.cpp:    geoclaw_vt->rpt2             = FC2D_GEOCLAW_RPT2;
fc2d_geoclaw.cpp:    gauges_vt->set_gauge_data     = geoclaw_read_gauges_data_default;
fc2d_geoclaw.cpp:    gauges_vt->create_gauge_files = geoclaw_create_gauge_files_default; 
fc2d_geoclaw.cpp:    gauges_vt->normalize_coordinates = geoclaw_gauge_normalize_coordinates;
fc2d_geoclaw.cpp:    gauges_vt->update_gauge       = geoclaw_gauge_update_default;
fc2d_geoclaw.cpp:    gauges_vt->print_gauge_buffer = geoclaw_print_gauges_default;
fc2d_geoclaw.cpp:    geoclaw_vt->is_set = 1;
fc2d_geoclaw.cpp:	FCLAW_ASSERT(fclaw_pointer_map_get(glob->vtables,"fc2d_geoclaw") == NULL);
fc2d_geoclaw.cpp:	fclaw_pointer_map_insert(glob->vtables, "fc2d_geoclaw", geoclaw_vt, fc2d_geoclaw_vt_destroy);
fc2d_geoclaw_fort.h:Copyright (c) 2012-2021 Carsten Burstedde, Donna Calhoun, Yu-Hsuan Shih
fc2d_geoclaw_fort.h:/* --------------------------------------- Typedefs ----------------------------------- */
fc2d_geoclaw_fort.h:/* ---------------------------------- GeoClaw functions ------------------------------- */
fc2d_geoclaw_fort.h:/* --------------------------------- Gauge functions ---------------------------------- */
fc2d_geoclaw_fort.h:/* ------------------------------- Time stepping functions ---------------------------- */
fc2d_geoclaw_fort.h:/* -------------------------------- Regridding functions ------------------------------ */
fc2d_geoclaw_fort.h:/* ---------------------------- Ghost filling - patch specific -------------------------- */
fc2d_geoclaw_fort.h:/* --------------------------------- Output functions ----------------------------------- */
fc2d_geoclaw_fort.h:/* ---------------------------------- Parallel ghost patches  -------------------------------- */
fc2d_geoclaw_fort.h:/* ------------------------------ Diagnostics functions ---------------------------- */
fc2d_geoclaw_fort.h:/* -------------------------- Misc GeoClaw specific functions ------------------------- */
fc2d_geoclaw_gauges_default.c:   1   8.6001000000e+01   1.0000000000e-03   0.000000e+00   1.000000e+10
fc2d_geoclaw_gauges_default.c:   2   8.6876000000e+01   1.0000000000e-03   0.000000e+00   1.000000e+10
fc2d_geoclaw_gauges_default.c:   3   8.7751000000e+01   1.0000000000e-03   0.000000e+00   1.000000e+10
fc2d_geoclaw_gauges_default.c:    /* -----------------------------------------------------
fc2d_geoclaw_gauges_default.c:    ----------------------------------------------------- */
fc2d_geoclaw_gauges_default.c:       Gauge coordinates (g->xc,g->yc) are whatever the user supplied above 
fc2d_geoclaw_gauges_default.c:    ax = fclaw_opt->ax;
fc2d_geoclaw_gauges_default.c:    bx = fclaw_opt->bx;
fc2d_geoclaw_gauges_default.c:    ay = fclaw_opt->ay;
fc2d_geoclaw_gauges_default.c:    by = fclaw_opt->by;
fc2d_geoclaw_gauges_default.c:    *xc = (g->xc - ax)/(bx-ax);
fc2d_geoclaw_gauges_default.c:    *yc = (g->yc - ay)/(by-ay);
fc2d_geoclaw_gauges_default.c:    guser->level = patch->level;
fc2d_geoclaw_gauges_default.c:    guser->tcurr = tcurr;
fc2d_geoclaw_gauges_default.c:        guser->qvar[m] = qvar[m];
fc2d_geoclaw_gauges_default.c:    guser->avar[0] = avar[0];   /* Just store bathymetry for now */
fc2d_geoclaw_gauges_default.c:       start at 0 and with kmax-1 */
fc2d_geoclaw_gauges_default.c:        double eta = guser->qvar[0] + guser->avar[0];
fc2d_geoclaw_gauges_default.c:        eta = fabs(eta) < 1e-99 ? 0 : eta; /* For reading in Matlab */
fc2d_geoclaw_gauges_default.c:                guser->level, guser->tcurr,
fc2d_geoclaw_gauges_default.c:                guser->qvar[0],guser->qvar[1],
fc2d_geoclaw_gauges_default.c:                guser->qvar[2],eta);
fc2d_geoclaw.h:  Copyright (c) 2012-2022 Carsten Burstedde, Donna Calhoun, Yu-Hsuan Shih, Scott Aiton
fc2d_geoclaw.h:/* ------------------------------------- Access functions ---------------------------------- */
fc2d_geoclaw.h:/* ------------------------------------- Virtual table ----------------------------------- */
fc2d_geoclaw.h.TEST.cpp:Copyright (c) 2012-2022 Carsten Burstedde, Donna Calhoun, Scott Aiton
fc2d_geoclaw.h.TEST.cpp:	CHECK_UNARY(fc2d_geoclaw_vt(glob)->is_set);
fc2d_geoclaw_options.c:Copyright (c) 2012-2022 Carsten Burstedde, Donna Calhoun, Scott Aiton
fc2d_geoclaw_options.c:    fclaw_options_add_int_array (opt, 0, "order", &geo_opt->order_string,
fc2d_geoclaw_options.c:                               "2 2", &geo_opt->order, 2,
fc2d_geoclaw_options.c:    sc_options_add_int (opt, 0, "mcapa", &geo_opt->mcapa, -1,
fc2d_geoclaw_options.c:                        "[geoclaw] Location of capacity function in aux array [-1]");
fc2d_geoclaw_options.c:    sc_options_add_bool (opt, 0, "src_term", &geo_opt->src_term, 0,
fc2d_geoclaw_options.c:    sc_options_add_bool (opt, 0, "use_fwaves", &geo_opt->use_fwaves, 0,
fc2d_geoclaw_options.c:                         "[geoclaw] Use fwaves flux-form [F]");
fc2d_geoclaw_options.c:    sc_options_add_int (opt, 0, "mwaves", &geo_opt->mwaves, 1,
fc2d_geoclaw_options.c:    fclaw_options_add_int_array (opt, 0, "mthlim", &geo_opt->mthlim_string, NULL,
fc2d_geoclaw_options.c:                                 &geo_opt->mthlim, geo_opt->mwaves,
fc2d_geoclaw_options.c:                                 "values 0-4) [NULL]");
fc2d_geoclaw_options.c:    fclaw_options_add_int_array (opt, 0, "mthbc", &geo_opt->mthbc_string, "1 1 1 1",
fc2d_geoclaw_options.c:                                 &geo_opt->mthbc, 4,
fc2d_geoclaw_options.c:    sc_options_add_double (opt, 0, "dry_tolerance_c", &geo_opt->dry_tolerance_c, 1.0,
fc2d_geoclaw_options.c:    sc_options_add_double (opt, 0, "wave_tolerance_c", &geo_opt->wave_tolerance_c, 1.0,
fc2d_geoclaw_options.c:                        &geo_opt->speed_tolerance_entries_c, 1,
fc2d_geoclaw_options.c:                                    &geo_opt->speed_tolerance_c_string, NULL,
fc2d_geoclaw_options.c:                                    &geo_opt->speed_tolerance_c, 
fc2d_geoclaw_options.c:                                    geo_opt->speed_tolerance_entries_c,
fc2d_geoclaw_options.c:    sc_options_add_int (opt, 0, "mbathy", &geo_opt->mbathy, 1,
fc2d_geoclaw_options.c:    sc_options_add_bool (opt, 0, "ascii-out", &geo_opt->ascii_out,1,
fc2d_geoclaw_options.c:                         "Output ascii files for post-processing [T]");
fc2d_geoclaw_options.c:    geo_opt->is_registered = 1;
fc2d_geoclaw_options.c:    geo_opt->method[0] = 0;  /* Time stepping is controlled outside of clawpack */
fc2d_geoclaw_options.c:    geo_opt->method[1] = geo_opt->order[0];
fc2d_geoclaw_options.c:    geo_opt->method[2] = geo_opt->order[1];
fc2d_geoclaw_options.c:    geo_opt->method[3] = 0;  /* No verbosity allowed in fortran subroutines */
fc2d_geoclaw_options.c:    geo_opt->method[4] = geo_opt->src_term;
fc2d_geoclaw_options.c:    geo_opt->method[5] = geo_opt->mcapa;
fc2d_geoclaw_options.c:    fclaw_options_convert_int_array (geo_opt->mthbc_string, &geo_opt->mthbc,4);
fc2d_geoclaw_options.c:    fclaw_options_convert_int_array (geo_opt->mthlim_string, &geo_opt->mthlim,
fc2d_geoclaw_options.c:                                     geo_opt->mwaves);
fc2d_geoclaw_options.c:    fclaw_options_convert_int_array (geo_opt->order_string, &geo_opt->order,
fc2d_geoclaw_options.c:    fclaw_options_convert_double_array (geo_opt->speed_tolerance_c_string,
fc2d_geoclaw_options.c:                                        &geo_opt->speed_tolerance_c,
fc2d_geoclaw_options.c:                                        geo_opt->speed_tolerance_entries_c);
fc2d_geoclaw_options.c:    fclaw_options_destroy_array (geo_opt->mthbc);
fc2d_geoclaw_options.c:    fclaw_options_destroy_array (geo_opt->order);
fc2d_geoclaw_options.c:    fclaw_options_destroy_array (geo_opt->mthlim);
fc2d_geoclaw_options.c:    fclaw_options_destroy_array (geo_opt->speed_tolerance_c);
fc2d_geoclaw_options.c:/* ------------------------------------------------------------------------
fc2d_geoclaw_options.c:  Generic functions - these call the functions above
fc2d_geoclaw_options.c:  ------------------------------------------------------------------------ */
fc2d_geoclaw_options.c:    FCLAW_ASSERT(geo_opt->is_registered != 0);
fc2d_geoclaw_options.c:    FCLAW_ASSERT (geo_opt->is_registered);
fc2d_geoclaw_options.c:    FCLAW_ASSERT (geo_opt->is_registered);
fc2d_geoclaw_options.c:/* ----------------------------------------------------------
fc2d_geoclaw_options.c:   ---------------------------------------------------------- */
fc2d_geoclaw_options.c:	   							fclaw_pointer_map_get(glob->options, "fc2d_geoclaw");
fc2d_geoclaw_options.c:	FCLAW_ASSERT(fclaw_pointer_map_get(glob->options,"fc2d_geoclaw") == NULL);
fc2d_geoclaw_options.c:	fclaw_pointer_map_insert(glob->options, "fc2d_geoclaw", geo_opt, NULL);
fc2d_geoclaw_options.h:Copyright (c) 2012-2022 Carsten Burstedde, Donna Calhoun, Scott Aiton
fc2d_geoclaw_options.h.TEST.cpp:Copyright (c) 2012-2022 Carsten Burstedde, Donna Calhoun, Scott Aiton
fc2d_geoclaw_output_ascii.c:Copyright (c) 2012 Carsten Burstedde, Donna Calhoun, Yu-Hsuan Shih
fc2d_geoclaw_output_ascii.c:    fclaw2d_global_t *glob = (fclaw2d_global_t*) s->glob;
fc2d_geoclaw_output_ascii.c:    int iframe = *((int *) s->user);    
fc2d_geoclaw_output_ascii.c:    fclaw2d_patch_get_info(glob->domain,patch,
fc2d_geoclaw_output_ascii.c:                                 &blockno,&glob->mpirank);
fc2d_geoclaw_output_ascii.c:    double time = glob->curr_time;
fc2d_geoclaw_output_ascii.c:    int ngrids = glob->domain->global_num_patches;
fc2d_geoclaw_output_ascii.c:    int meqn = clawpatch_opt->meqn;
fc2d_geoclaw_output_ascii.c:    int maux = clawpatch_opt->maux;
fc2d_geoclaw_output_ascii.c:    int mbc = clawpatch_opt->mbc;
fc2d_geoclaw_output_ascii.c:/* --------------------------------------------------------------
fc2d_geoclaw_output_ascii.c:   ------------------------------------------------------------ */
fc2d_geoclaw_output_ascii.c:    fclaw2d_domain_t *domain = glob->domain;
fc2d_geoclaw_output_ascii.c:    /* BEGIN NON-SCALABLE CODE */
fc2d_geoclaw_output_ascii.c:    if (domain->mpirank == 0)
fc2d_geoclaw_output_ascii.c:    /* END OF NON-SCALABLE CODE */
fc2d_geoclaw_run.c:/*  -----------------------------------------------------------------
fc2d_geoclaw_run.c:    -- saving time steps
fc2d_geoclaw_run.c:    -- restoring time steps
fc2d_geoclaw_run.c:    -- Time stepping, based on when output files should be created.
fc2d_geoclaw_run.c:    ----------------------------------------------------------------- */
fc2d_geoclaw_run.c:    fclaw2d_patch_restore_step(s->glob,this_patch);
fc2d_geoclaw_run.c:    //fclaw2d_time_sync_reset(glob,fopt->minlevel,fopt->maxlevel,0);
fc2d_geoclaw_run.c:    fclaw2d_patch_save_step(s->glob,this_patch);
fc2d_geoclaw_run.c:/* -------------------------------------------------------------------------------
fc2d_geoclaw_run.c:   -------------------------------------------------------------------------------- */
fc2d_geoclaw_run.c:    /* -----------------------------------------------------------------------
fc2d_geoclaw_run.c:       --------------------------------------------------------------------- */
fc2d_geoclaw_run.c:        double dt0 = dtopo_interval[0] - tstart_outer;
fc2d_geoclaw_run.c:        glob->curr_dt = dt0;  
fc2d_geoclaw_run.c:        glob->curr_time = tstart_local;
fc2d_geoclaw_run.c:        glob->curr_time += dt0;
fc2d_geoclaw_run.c:    /* -----------------------------------------------------------------------
fc2d_geoclaw_run.c:       --------------------------------------------------------------------- */
fc2d_geoclaw_run.c:    if (fabs(tend_outer - tend_local) < 0.01*(tend_outer-tstart_outer))
fc2d_geoclaw_run.c:    double dt_dtopo = tend_local - tstart_local;
fc2d_geoclaw_run.c:    glob->curr_dt = dt1;  
fc2d_geoclaw_run.c:        double tstart = glob->curr_time;
fc2d_geoclaw_run.c:        glob->curr_time += dt1;
fc2d_geoclaw_run.c:    /* -----------------------------------------------------------------------
fc2d_geoclaw_run.c:       --------------------------------------------------------------------- */
fc2d_geoclaw_run.c:        double dt2 = tend_outer - tstart_local;
fc2d_geoclaw_run.c:        glob->curr_time += dt2;
fc2d_geoclaw_run.c:/* -------------------------------------------------------------------------------
fc2d_geoclaw_run.c:   -------------------------------------------------------------------------------- */
fc2d_geoclaw_run.c:    fclaw2d_domain_t** domain = &glob->domain;
fc2d_geoclaw_run.c:    double final_time = fclaw_opt->tfinal;
fc2d_geoclaw_run.c:    int nout = fclaw_opt->nout;
fc2d_geoclaw_run.c:    double initial_dt = fclaw_opt->initial_dt;
fc2d_geoclaw_run.c:    int level_factor = pow_int(2,fclaw_opt->maxlevel - fclaw_opt->minlevel);
fc2d_geoclaw_run.c:    double dt_outer = (final_time-t0)/((double) nout);
fc2d_geoclaw_run.c:        glob->curr_time = t_curr;
fc2d_geoclaw_run.c:            if (!fclaw_opt->use_fixed_dt)
fc2d_geoclaw_run.c:               the next step.  Of course if 'tend - t_curr > dt_minlevel',
fc2d_geoclaw_run.c:            if (fclaw_opt->advance_one_step)
fc2d_geoclaw_run.c:            double tol = 1e-2*dt_step;
fc2d_geoclaw_run.c:            if (!fclaw_opt->use_fixed_dt)
fc2d_geoclaw_run.c:                double small_step = tend-(t_curr+dt_step);
fc2d_geoclaw_run.c:                    dt_step = tend - t_curr;  // <= 'dt_minlevel + tol'
fc2d_geoclaw_run.c:                        /* We have (tend-t_curr) < dt_minlevel, and
fc2d_geoclaw_run.c:                /* glob->curr_time has been updated */  
fc2d_geoclaw_run.c:                tc = glob->curr_time;
fc2d_geoclaw_run.c:                glob->curr_dt = dt_step;
fc2d_geoclaw_run.c:            if (fclaw_opt->reduce_cfl)
fc2d_geoclaw_run.c:                fclaw2d_timer_start (&glob->timers[FCLAW2D_TIMER_CFL_COMM]);
fc2d_geoclaw_run.c:                fclaw2d_timer_stop (&glob->timers[FCLAW2D_TIMER_CFL_COMM]);                
fc2d_geoclaw_run.c:            fclaw_global_productionf("Level %d (%d-%d) step %5d : dt = %12.3e; maxcfl (step) = " \
fc2d_geoclaw_run.c:                                     fclaw_opt->minlevel,
fc2d_geoclaw_run.c:                                     (*domain)->global_minlevel,
fc2d_geoclaw_run.c:                                     (*domain)->global_maxlevel,
fc2d_geoclaw_run.c:                if ((maxcfl_step > fclaw_opt->max_cfl) & fclaw_opt->reduce_cfl)
fc2d_geoclaw_run.c:                    if (!fclaw_opt->use_fixed_dt)
fc2d_geoclaw_run.c:                        dt_minlevel = dt_minlevel*fclaw_opt->desired_cfl/maxcfl_step;
fc2d_geoclaw_run.c:            if (!fclaw_opt->use_fixed_dt)
fc2d_geoclaw_run.c:                double dt_new = dt_minlevel*fclaw_opt->desired_cfl/maxcfl_step;
fc2d_geoclaw_run.c:            glob->curr_time = t_curr;
fc2d_geoclaw_run.c:            if (fclaw_opt->advance_one_step)
fc2d_geoclaw_run.c:            if (fclaw_opt->regrid_interval > 0)
fc2d_geoclaw_run.c:                if (n_inner % fclaw_opt->regrid_interval == 0)
fc2d_geoclaw_run.c:        glob->curr_time = t_curr;
fc2d_geoclaw_run.c:    // fclaw2d_domain_t** domain = &glob->domain;
fc2d_geoclaw_run.c:    fclaw2d_domain_t** domain = &glob->domain;
fc2d_geoclaw_run.c:    double initial_dt = fclaw_opt->initial_dt;
fc2d_geoclaw_run.c:    //fclaw2d_time_sync_reset(glob,fclaw_opt->minlevel,fclaw_opt->maxlevel,1);
fc2d_geoclaw_run.c:    glob->curr_time = t0;
fc2d_geoclaw_run.c:    int nstep_outer = fclaw_opt->nout;
fc2d_geoclaw_run.c:    int nstep_inner = fclaw_opt->nstep;
fc2d_geoclaw_run.c:    int nregrid_interval = fclaw_opt->regrid_interval;
fc2d_geoclaw_run.c:    int level_factor = pow_int(2,fclaw_opt->maxlevel-fclaw_opt->minlevel);
fc2d_geoclaw_run.c:    if (!fclaw_opt->subcycle)
fc2d_geoclaw_run.c:        if (fclaw_opt->advance_one_step)
fc2d_geoclaw_run.c:            if (!fclaw_opt->outstyle_uses_maxlevel)
fc2d_geoclaw_run.c:                /* Multiply nout/nstep by 2^(maxlevel-minlevel) so that
fc2d_geoclaw_run.c:                   and non-subcycled cases.
fc2d_geoclaw_run.c:        if (!fclaw_opt->subcycle && fclaw_opt->advance_one_step)
fc2d_geoclaw_run.c:            /* if domain->global_maxlevel < fclaw_opt->maxlevel, this choice
fc2d_geoclaw_run.c:        if (!fclaw_opt->use_fixed_dt)
fc2d_geoclaw_run.c:            /* glob->curr_time has been updated */  
fc2d_geoclaw_run.c:            tc = glob->curr_time;
fc2d_geoclaw_run.c:            glob->curr_dt = dt_step;
fc2d_geoclaw_run.c:        /* This is a collective communication - everybody needs to wait here. */
fc2d_geoclaw_run.c:        if (fclaw_opt->reduce_cfl)
fc2d_geoclaw_run.c:             fclaw2d_timer_start (&glob->timers[FCLAW2D_TIMER_CFL_COMM]);
fc2d_geoclaw_run.c:             fclaw2d_timer_stop (&glob->timers[FCLAW2D_TIMER_CFL_COMM]);     
fc2d_geoclaw_run.c:        int level2print = (fclaw_opt->advance_one_step && fclaw_opt->outstyle_uses_maxlevel) ?
fc2d_geoclaw_run.c:                          fclaw_opt->maxlevel : fclaw_opt->minlevel;
fc2d_geoclaw_run.c:        fclaw_global_productionf("Level %d (%d-%d) step %5d : dt = %12.3e; maxcfl (step) = " \
fc2d_geoclaw_run.c:                                 (*domain)->global_minlevel,
fc2d_geoclaw_run.c:                                 (*domain)->global_maxlevel,
fc2d_geoclaw_run.c:            if (fclaw_opt->reduce_cfl & (maxcfl_step > fclaw_opt->max_cfl))
fc2d_geoclaw_run.c:                if (!fclaw_opt->use_fixed_dt)
fc2d_geoclaw_run.c:                    dt_minlevel = dt_minlevel*fclaw_opt->desired_cfl/maxcfl_step;
fc2d_geoclaw_run.c:        else if (maxcfl_step > fclaw_opt->max_cfl)
fc2d_geoclaw_run.c:        glob->curr_time = t_curr;
fc2d_geoclaw_run.c:        if (!fclaw_opt->use_fixed_dt)
fc2d_geoclaw_run.c:            dt_minlevel = dt_minlevel*fclaw_opt->desired_cfl/maxcfl_step;
fc2d_geoclaw_run.c:        if (fclaw_opt->regrid_interval > 0)
fc2d_geoclaw_run.c:        if (fclaw_opt->advance_one_step)
fc2d_geoclaw_run.c:    double initial_dt = fclaw_opt->initial_dt;
fc2d_geoclaw_run.c:    int nstep_outer = fclaw_opt->nout;
fc2d_geoclaw_run.c:    int nstep_inner = fclaw_opt->nstep;
fc2d_geoclaw_run.c:    glob->curr_time = t_curr;
fc2d_geoclaw_run.c:        int level2print = (fclaw_opt->advance_one_step && fclaw_opt->outstyle_uses_maxlevel) ?
fc2d_geoclaw_run.c:                          fclaw_opt->maxlevel : fclaw_opt->minlevel;
fc2d_geoclaw_run.c:        glob->curr_time = t_curr;
fc2d_geoclaw_run.c:        if (fclaw_opt->regrid_interval > 0)
fc2d_geoclaw_run.c:            if (n % fclaw_opt->regrid_interval == 0)
fc2d_geoclaw_run.c:/* ------------------------------------------------------------------
fc2d_geoclaw_run.c:   ---------------------------------------------------------------- */
fc2d_geoclaw_run.c:    switch (fclaw_opt->outstyle)
fc2d_geoclaw_run.c:        fclaw_global_essentialf("Outstyle %d not implemented yet in GeoClaw run\n", fclaw_opt->outstyle);
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:  !!     If coordinate_system=2 then lat-lon coordinates on the sphere and
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:  !!        aux(2,i,j) = area ratio (capacity function -- set mcapa = 2)
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:  REAL(kind=8), INTENT(inout) :: aux(maux,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:  !! Lat-Long coordinate system in use, check input variables
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:  !! Check below is new in 5.2.1 -- need to rethink for storm surge
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:        !! for some reason it bombs, e.g. in bowl-radial if maux>1.
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:        aux(2,0:mint,0:my-mint) = 1.d0
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:        aux(2,mx-mint+1:mx+1,mint+1:my+1) = 1.d0
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:        aux(2,0:mx-mint,my-mint+1:my+1) = 1.d0    
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:     aux(friction_index,0:mint,0:my-mint) = 0.d0
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:     aux(friction_index,mx-mint+1:mx+1,mint+1:my+1) = 0.d0
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:     aux(friction_index,0:mx-mint,my-mint+1:my+1) = 0.d0     
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:     aux(wind_index,0:mint,0:my-mint) = 0.d0
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:     aux(wind_index+1,0:mint,0:my-mint) = 0.d0
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:     aux(wind_index,mx-mint+1:mx+1,mint+1:my+1) = 0.d0
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:     aux(wind_index+1,mx-mint+1:mx+1,mint+1:my+1) = 0.d0
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:     aux(wind_index,0:mx-mint,my-mint+1:my+1) = 0.d0  
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:     aux(wind_index+1,0:mx-mint,my-mint+1:my+1) = 0.d0    
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:     aux(pressure_index,0:mint,0:my-mint) = ambient_pressure
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:     aux(pressure_index,mx-mint+1:mx+1,mint+1:my+1) = ambient_pressure
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:     aux(pressure_index,0:mx-mint,my-mint+1:my+1) = ambient_pressure
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:     FORALL (ii=0:mint,jj=0:my-mint)
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:        aux(1,ii,jj) = test_topo(xlow + (ii - 0.5d0) * dx,       &
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:             ylow + (jj - 0.5d0) * dy)
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:        aux(1,ii,jj) = test_topo(xlow + (ii - 0.5d0) * dx,       &
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:             ylow + (jj - 0.5d0) * dy)
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:     FORALL (ii=mx-mint+1:mx+1,jj=mint+1:my+1)
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:        aux(1,ii,jj) = test_topo(xlow + (ii - 0.5d0) * dx,       &
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:             ylow + (jj - 0.5d0) * dy)
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:     FORALL (ii=0:mx-mint,jj=my-mint+1:my+1)
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:        aux(1,ii,jj) = test_topo(xlow + (ii - 0.5d0) * dx,       &
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:             ylow + (jj - 0.5d0) * dy)
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:  ilo = FLOOR((xlow - xlower + .05d0*dx)/dx)
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:  jlo = FLOOR((ylow - ylower + .05d0*dy)/dy)
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:  DO jj = 0,my-mint
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:     ym = ylower + (jlo+jj-1.d0) * dy
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:        xm = xlower + (ilo+ii-1.d0) * dx
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:        !! Set lat-long cell info
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:           aux(2,ii,jj) = deg2rad * earth_radius**2 * (SIN(yp * deg2rad) - SIN(ym * deg2rad)) / dy
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:     ym = ylower + (jlo+jj-1.d0) * dy
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:        xm = xlower + (ilo+ii-1.d0) * dx
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:        !! Set lat-long cell info
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:           aux(2,ii,jj) = deg2rad * earth_radius**2 * (SIN(yp * deg2rad) - SIN(ym * deg2rad)) / dy
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:     ym = ylower + (jlo+jj-1.d0) * dy
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:     DO ii = mx-mint+1,mx+1
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:        xm = xlower + (ilo+ii-1.d0) * dx
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:        !! Set lat-long cell info
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:           aux(2,ii,jj) = deg2rad * earth_radius**2 * (SIN(yp * deg2rad) - SIN(ym * deg2rad)) / dy
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:  DO jj = my-mint+1,my+1
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:     ym = ylower + (jlo+jj-1.d0) * dy
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:     DO ii = 0,mx-mint
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:        xm = xlower + (ilo+ii-1.d0) * dx
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:        !! Set lat-long cell info
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:           aux(2,ii,jj) = deg2rad * earth_radius**2 * (SIN(yp * deg2rad) - SIN(ym * deg2rad)) / dy
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:  DO jj=0,my-mint
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:     y = ylower + (jlo+jj-.5d0) * dy
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:           x = xlower + (ilo+ii-.5d0) * dx
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:           iint = ii + MAX(0, CEILING((xlower-x)/dx)) &
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:                - MAX(0, CEILING((x-xupper)/dx))
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:           jint = jj + MAX(0, CEILING((ylower-y)/dy)) &
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:                - MAX(0, CEILING((y-yupper)/dy))
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:     y = ylower + (jlo+jj-.5d0) * dy
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:           x = xlower + (ilo+ii-.5d0) * dx
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:           iint = ii + MAX(0, CEILING((xlower-x)/dx)) &
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:                - MAX(0, CEILING((x-xupper)/dx))
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:           jint = jj + MAX(0, CEILING((ylower-y)/dy)) &
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:                - MAX(0, CEILING((y-yupper)/dy))
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:     y = ylower + (jlo+jj-.5d0) * dy
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:        DO ii=mx-mint+1,mx+1
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:           x = xlower + (ilo+ii-.5d0) * dx
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:           iint = ii + MAX(0, CEILING((xlower-x)/dx)) &
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:                - MAX(0, CEILING((x-xupper)/dx))
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:           jint = jj + MAX(0, CEILING((ylower-y)/dy)) &
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:                - MAX(0, CEILING((y-yupper)/dy))
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:  DO jj=my-mint+1,my+1
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:     y = ylower + (jlo+jj-.5d0) * dy
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:        DO ii=0,mx-mint
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:           x = xlower + (ilo+ii-.5d0) * dx
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:           iint = ii + MAX(0, CEILING((xlower-x)/dx)) &
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:                - MAX(0, CEILING((x-xupper)/dx))
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:           jint = jj + MAX(0, CEILING((ylower-y)/dy)) &
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:                - MAX(0, CEILING((y-yupper)/dy))
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:     x =  xlower + (ilo+ii-.5d0) * dx
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:        DO jj=0,my-mint
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:           y = ylower + (jlo+jj-.5d0) * dy
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:           iint = ii + MAX(0, CEILING((xlower-x)/dx)) &
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:                - MAX(0, CEILING((x-xupper)/dx))
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:           jint = jj + MAX(0, CEILING((ylower-y)/dy)) &
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:                - MAX(0, CEILING((y-yupper)/dy))
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:     x =  xlower + (ilo+ii-.5d0) * dx
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:           y = ylower + (jlo+jj-.5d0) * dy
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:           iint = ii + MAX(0, CEILING((xlower-x)/dx)) &
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:                - MAX(0, CEILING((x-xupper)/dx))
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:           jint = jj + MAX(0, CEILING((ylower-y)/dy)) &
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:                - MAX(0, CEILING((y-yupper)/dy))
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:  DO ii=mx-mint+1,mx+1
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:     x =  xlower + (ilo+ii-.5d0) * dx
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:           y = ylower + (jlo+jj-.5d0) * dy
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:           iint = ii + MAX(0, CEILING((xlower-x)/dx)) &
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:                - MAX(0, CEILING((x-xupper)/dx))
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:           jint = jj + MAX(0, CEILING((ylower-y)/dy)) &
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:                - MAX(0, CEILING((y-yupper)/dy))
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:  DO ii=0,mx-mint
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:     x =  xlower + (ilo+ii-.5d0) * dx
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:        DO jj=my-mint+1,my+1
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:           y = ylower + (jlo+jj-.5d0) * dy
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:           iint = ii + MAX(0, CEILING((xlower-x)/dx)) &
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:                - MAX(0, CEILING((x-xupper)/dx))
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:           jint = jj + MAX(0, CEILING((ylower-y)/dy)) &
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:                - MAX(0, CEILING((y-yupper)/dy))
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:     DO jj=1-mbc,my+mbc
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:        DO ii=1-mbc,mx+mbc
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:           x = xlow + (ii-0.5d0)*dx
fclaw2d_source/fc2d_geoclaw_setaux_ghost_fort.f:           y = ylow + (jj-0.5d0)*dy
fclaw2d_source/fc2d_geoclaw_timeinterp_fort.f:      double precision   qcurr(meqn,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_timeinterp_fort.f:      double precision   qlast(meqn,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_timeinterp_fort.f:      double precision qinterp(meqn,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_timeinterp_fort.f:c     # interpolate from time-interpolated levels, we only
fclaw2d_source/fc2d_geoclaw_timeinterp_fort.f:         do j = 1-ng,my-mint
fclaw2d_source/fc2d_geoclaw_timeinterp_fort.f:            do i = 1-ng,mint
fclaw2d_source/fc2d_geoclaw_timeinterp_fort.f:     &               alpha*(qcurr(m,i,j)-qlast(m,i,j))
fclaw2d_source/fc2d_geoclaw_timeinterp_fort.f:         do j = 1-ng,mint
fclaw2d_source/fc2d_geoclaw_timeinterp_fort.f:     &               alpha*(qcurr(m,i,j)-qlast(m,i,j))
fclaw2d_source/fc2d_geoclaw_timeinterp_fort.f:            do i = mx-mint+1,mx+ng
fclaw2d_source/fc2d_geoclaw_timeinterp_fort.f:     &               alpha*(qcurr(m,i,j)-qlast(m,i,j))
fclaw2d_source/fc2d_geoclaw_timeinterp_fort.f:         do j = my-mint+1,my+ng
fclaw2d_source/fc2d_geoclaw_timeinterp_fort.f:            do i = 1-ng,mx-mint
fclaw2d_source/fc2d_geoclaw_timeinterp_fort.f:     &               alpha*(qcurr(m,i,j)-qlast(m,i,j))
fclaw2d_source/fc2d_geoclaw_timeinterp_fort.f:      kfinal = k-1;
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:c     # ----------------------------------------------------------
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:c     # Interpolation routines - (i,j,mq) ordering
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:c     # ----------------------------------------------------------
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:c     # ----------------------------------------------------------
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:c     # ----------------------------------------------------------
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:c     # This routine is used for both mapped and non-mapped
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:c     # ----------------------------------------------------------
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:      double precision qfine(meqn,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:      double precision qcoarse(meqn,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:      double precision aux_coarse(maux,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:      double precision aux_fine(maux,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:      double precision etabarc(-1:1, -1:1), h, b
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:      integer i2(0:rr2-1),j2(0:rr2-1)
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:      integer ii,jj,dc(2),df(2,0:rr2-1),iff,jff
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:      double precision shiftx(0:rr2-1),shifty(0:rr2-1)
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:c           # Map (0,1) to (-1/4,1/4) (locations of fine grid points)
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:            shiftx(m) = (ii-0.5d0)/2.d0
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:            shifty(m) = (jj-0.5d0)/2.d0
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:               do m = 0,r2-1
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:                     do ii = -1, 1
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:                        do jj = -1, 1
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:                     sl = qc - etabarc(-1,0)
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:                     sr = etabarc(1,0) - qc
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:                     sl = qc - etabarc(0,-1)
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:                     sr = etabarc(0,1) - qc
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:                     do m = 0,rr2-1
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:     &                        -aux_fine(mbathy,iff,jff)
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:                     sl = (qc - qcoarse(mq,ic-1,jc))
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:                     sr = (qcoarse(mq,ic+1,jc) - qc)
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:                     sl = (qc - qcoarse(mq,ic,jc-1))
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:                     sr = (qcoarse(mq,ic,jc+1) - qc)
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:                     do m = 0,rr2-1
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:c-----------------------------------------------------------------------------
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:c              # ---------------------------------------------
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:c              # Two 'half-size' neighbors will be passed into
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:c              # have to be filled in by the other half-size
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:c              # ---------------------------------------------
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:               do m = 0,r2-1
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:                     do ii = -1, 1
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:                        do jj = -1, 1
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:                     sl = qc - etabarc(-1,0)
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:                     sr = etabarc(1,0) - qc
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:                     sl = qc - etabarc(0,-1)
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:                     sr = etabarc(0,1) - qc
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:                     do m = 0,rr2-1
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:     &                        - aux_fine(mbathy,iff,jff)
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:                     sl = (qc - qcoarse(mq,ic-1,jc))
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:                     sr = (qcoarse(mq,ic+1,jc) - qc)
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:                     sl = (qc - qcoarse(mq,ic,jc-1))
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:                     sr = (qcoarse(mq,ic,jc+1) - qc)
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:                     do m = 0,rr2-1
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:      double precision qcoarse(meqn,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:      double precision qfine(meqn,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:      double precision aux_coarse(maux,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:      double precision aux_fine(maux,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:      double precision etabarc(-1:1, -1:1), h, b
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:      integer i2(0:rr2-1),j2(0:rr2-1)
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:      integer ii,jj,iff,jff,dc(2),df(2,0:rr2-1)
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:      double precision shiftx(0:rr2-1), shifty(0:rr2-1)
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:c           # Map (0,1) to (-1/4,1/4) (locations of fine grid points)
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:            shiftx(m) = (ii-0.5d0)/2.d0
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:            shifty(m) = (jj-0.5d0)/2.d0
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:            do ii = -1, 1
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:               do jj = -1, 1
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:            sl = qc - etabarc(-1,0)
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:            sr = etabarc(1,0) - qc
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:            sl = qc - etabarc(0,-1)
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:            sr = etabarc(0,1) - qc
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:            do m = 0,rr2-1
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:     &               - aux_fine(mbathy,iff,jff)
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:            sl = (qc - qcoarse(mq,ic-1,jc))
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:            sr = (qcoarse(mq,ic+1,jc) - qc)
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:            sl = (qc - qcoarse(mq,ic,jc-1))
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:            sr = (qcoarse(mq,ic,jc+1) - qc)
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:            do m = 0,rr2-1
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:      double precision qcoarse(meqn,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:      double precision qfine(meqn,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:      double precision aux_coarse(maux,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:      double precision aux_fine(maux,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:      double precision uc(-1:1,-1:1), uf
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:      double precision etabarc(-1:1, -1:1), h, b, u, hfsum
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:      jg = (igrid-ig)/refratio
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:      i1 = 1-ig
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:      i2 = mx/p4est_refineFactor + (1-ig)
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:      j1 = 1-jg
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:      j2 = my/p4est_refineFactor + (1-jg)
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:               do ii = -1, 1
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:                  do jj = -1, 1
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:c--------------start interpolation
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:                  sl = qc - etabarc(-1,0)
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:                  sr = etabarc(1,0) - qc
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:                  sl = qc - etabarc(0,-1)
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:                  sr = etabarc(0,1) - qc
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:                        shiftx = (ii - refratio/2.d0 - 0.5d0)/refratio
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:                        shifty = (jj - refratio/2.d0 - 0.5d0)/refratio
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:                        iff = (i-1)*refratio + ii
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:                        jf = (j-1)*refratio + jj
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:                        qf = qc + shiftx*gradx + shifty*grady -
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:                  sl = (qc - qcoarse(mq,ic-1,jc))
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:                  sr = (qcoarse(mq,ic+1,jc) - qc)
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:                  sl = (qc - qcoarse(mq,ic,jc-1))
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:                  sr = (qcoarse(mq,ic,jc+1) - qc)
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:                        shiftx = (ii - refratio/2.d0 - 0.5d0)/refratio
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:                        shifty = (jj - refratio/2.d0 - 0.5d0)/refratio
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:                        iff = (i-1)*refratio + ii
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:                        jf = (j-1)*refratio + jj
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:c------------check to make sure we are not creating any new extrema
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:c                  do ii = -1,1
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:c                     do jj = -1,1
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:c                  coarseumax = -1d99
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:c                  do ii = -1,1
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:c                     do jj = -1,1
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:c                        iff = (i-1)*refratio + ii
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:c                        jf = (j-1)*refratio + jj
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:c                           iff = (i-1)*refratio + ii
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:c                           jf = (j-1)*refratio + jj
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:c------end of checking to make sure we are not creating any new extrema
fclaw2d_source/fc2d_geoclaw_interpolate_fort.f:c------end of interpolation
fclaw2d_source/fc2d_geoclaw_local_ghost_pack.f:      double precision qdata(meqn,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_local_ghost_pack.f:      double precision area(-mbc:mx+mbc+1,-mbc:my+mbc+1)
fclaw2d_source/fc2d_geoclaw_local_ghost_pack.f:         do j = 1-nghost,my-mint
fclaw2d_source/fc2d_geoclaw_local_ghost_pack.f:            do ibc = 1-nghost,mint
fclaw2d_source/fc2d_geoclaw_local_ghost_pack.f:         do jbc = 1-nghost,mint
fclaw2d_source/fc2d_geoclaw_local_ghost_pack.f:            do ibc = mx-mint+1,mx+nghost
fclaw2d_source/fc2d_geoclaw_local_ghost_pack.f:         do jbc = my-mint+1,my+nghost
fclaw2d_source/fc2d_geoclaw_local_ghost_pack.f:            do i = 1-nghost,mx-mint
fclaw2d_source/fc2d_geoclaw_local_ghost_pack.f:      kfinal = k - 1
fclaw2d_source/fc2d_geoclaw_local_ghost_pack.f:      do j = 1-nghost,my-mint
fclaw2d_source/fc2d_geoclaw_local_ghost_pack.f:         do ibc = 1-nghost,mint
fclaw2d_source/fc2d_geoclaw_local_ghost_pack.f:      do jbc = 1-nghost,mint
fclaw2d_source/fc2d_geoclaw_local_ghost_pack.f:         do ibc = mx-mint+1,mx+nghost
fclaw2d_source/fc2d_geoclaw_local_ghost_pack.f:      do jbc = my-mint+1,my+nghost
fclaw2d_source/fc2d_geoclaw_local_ghost_pack.f:         do i = 1-nghost,mx-mint
fclaw2d_source/fc2d_geoclaw_local_ghost_pack.f:      kfinal = k-1
fclaw2d_source/fc2d_geoclaw_local_ghost_pack.f:      double precision q(meqn,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_local_ghost_pack.f:         do j = 1-mbc,my
fclaw2d_source/fc2d_geoclaw_local_ghost_pack.f:               q(mq,1-ibc,j) = val
fclaw2d_source/fc2d_geoclaw_local_ghost_pack.f:               q(mq,i,1-jbc) = val
fclaw2d_source/fc2d_geoclaw_local_ghost_pack.f:            do i = 1-mbc,mx
fclaw2d_source/fc2d_geoclaw_local_ghost_pack.f:      double precision q(1-mbc:mx+mbc,1-mbc:my+mbc,meqn)
fclaw2d_source/fc2d_geoclaw_local_ghost_pack.f:               q(mq,1-ibc,1-jbc) = value
fclaw2d_source/fc2d_geoclaw_local_ghost_pack.f:               q(mq,mx+ibc,1-jbc) = value
fclaw2d_source/fc2d_geoclaw_local_ghost_pack.f:               q(mq,1-ibc,my+jbc) = value
fclaw2d_source/fc2d_geoclaw_output_ascii_fort.f:      do ipos = 10, 7, -1
fclaw2d_source/fc2d_geoclaw_output_ascii_fort.f:      double precision q(meqn,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_output_ascii_fort.f:      double precision aux(maux,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_output_ascii_fort.f:      do ipos = 10, 7, -1
fclaw2d_source/fc2d_geoclaw_output_ascii_fort.f:               if (abs(q(mq,i,j)) .lt. 1d-99) then
fclaw2d_source/fc2d_geoclaw_output_ascii_fort.f:            if (abs(eta) .lt. 1d-99) then
fclaw2d_source/fc2d_geoclaw_tag4refinement_fort.f90:    DOUBLE PRECISION, intent(in) :: q(meqn,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_tag4refinement_fort.f90:    DOUBLE PRECISION, INTENT(in) :: aux(maux,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_tag4refinement_fort.f90:            xc = xlower + (i-0.5)*dx
fclaw2d_source/fc2d_geoclaw_tag4refinement_fort.f90:            yc = ylower + (j-0.5)*dy
fclaw2d_source/fc2d_geoclaw_tag4refinement_fort.f90:!!          # -1 : Not conclusive (possibly ghost cell); don't tag for refinement
fclaw2d_source/fc2d_geoclaw_local_ghost_pack_fort.f:      double precision qdata(meqn,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_local_ghost_pack_fort.f:      double precision area(-mbc:mx+mbc+1,-mbc:my+mbc+1)
fclaw2d_source/fc2d_geoclaw_local_ghost_pack_fort.f:      do j = 1-nghost,my-mint
fclaw2d_source/fc2d_geoclaw_local_ghost_pack_fort.f:         do ibc = 1-nghost,mint
fclaw2d_source/fc2d_geoclaw_local_ghost_pack_fort.f:      do jbc = 1-nghost,mint
fclaw2d_source/fc2d_geoclaw_local_ghost_pack_fort.f:         do ibc = mx-mint+1,mx+nghost
fclaw2d_source/fc2d_geoclaw_local_ghost_pack_fort.f:      do jbc = my-mint+1,my+nghost
fclaw2d_source/fc2d_geoclaw_local_ghost_pack_fort.f:         do i = 1-nghost,mx-mint
fclaw2d_source/fc2d_geoclaw_local_ghost_pack_fort.f:      kfinal = k - 1
fclaw2d_source/fc2d_geoclaw_local_ghost_pack_fort.f:      do j = 1-nghost,my-mint
fclaw2d_source/fc2d_geoclaw_local_ghost_pack_fort.f:         do ibc = 1-nghost,mint
fclaw2d_source/fc2d_geoclaw_local_ghost_pack_fort.f:      do jbc = 1-nghost,mint
fclaw2d_source/fc2d_geoclaw_local_ghost_pack_fort.f:         do ibc = mx-mint+1,mx+nghost
fclaw2d_source/fc2d_geoclaw_local_ghost_pack_fort.f:      do jbc = my-mint+1,my+nghost
fclaw2d_source/fc2d_geoclaw_local_ghost_pack_fort.f:         do i = 1-nghost,mx-mint
fclaw2d_source/fc2d_geoclaw_local_ghost_pack_fort.f:      kfinal = k-1
fclaw2d_source/fc2d_geoclaw_local_ghost_pack_fort.f:      double precision q(meqn,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_local_ghost_pack_fort.f:         do j = 1-mbc,my
fclaw2d_source/fc2d_geoclaw_local_ghost_pack_fort.f:               q(mq,1-ibc,j) = val
fclaw2d_source/fc2d_geoclaw_local_ghost_pack_fort.f:               q(mq,i,1-jbc) = val
fclaw2d_source/fc2d_geoclaw_local_ghost_pack_fort.f:            do i = 1-mbc,mx
fclaw2d_source/fc2d_geoclaw_local_ghost_pack_fort.f:      double precision q(1-mbc:mx+mbc,1-mbc:my+mbc,meqn)
fclaw2d_source/fc2d_geoclaw_local_ghost_pack_fort.f:               q(mq,1-ibc,1-jbc) = value
fclaw2d_source/fc2d_geoclaw_local_ghost_pack_fort.f:               q(mq,mx+ibc,1-jbc) = value
fclaw2d_source/fc2d_geoclaw_local_ghost_pack_fort.f:               q(mq,1-ibc,my+jbc) = value
fclaw2d_source/fc2d_geoclaw_flag2refine_fort.f90:        y = ylower +  (j-0.5d0)*dy
fclaw2d_source/fc2d_geoclaw_flag2refine_fort.f90:        y1 = ylower + (j-1)*dy
fclaw2d_source/fc2d_geoclaw_flag2refine_fort.f90:          x = xlower +  (i-0.5d0)*dx
fclaw2d_source/fc2d_geoclaw_flag2refine_fort.f90:          x1 = xlower +  (i-1)*dx
fclaw2d_source/fc2d_geoclaw_flag2refine_fort.f90:                        !     ! IF (abs(eta - sea_level) > wave_tolerance) THEN
fclaw2d_source/fc2d_geoclaw_flag2refine_fort.f90:                            ! IF (abs(eta - sea_level) > wave_tolerance) THEN
fclaw2d_source/fc2d_geoclaw_flag2refine_fort.f90:                        IF (abs(eta - sea_level) > wave_tolerance) THEN
fclaw2d_source/fc2d_geoclaw_flag2refine_fort.f90:                !         IF (abs(eta - sea_level) > th_factor*wave_tolerance) THEN
fclaw2d_source/fc2d_geoclaw_flag2refine_fort.f90:                !         ! refine at maximum velocity-depth product is 0.5 m/s
fclaw2d_source/fc2d_geoclaw_diagnostics_fort.f:c    # ----------------------------------------------------------------------------------
fclaw2d_source/fc2d_geoclaw_diagnostics_fort.f:c    # ----------------------------------------------------------------------------------
fclaw2d_source/fc2d_geoclaw_diagnostics_fort.f:      double precision q(meqn,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_diagnostics_fort.f:                  y = q(i,j,m)*area(i,j) - c_kahan
fclaw2d_source/fc2d_geoclaw_diagnostics_fort.f:                  c_kahan = (t-sum(m)) - y
fclaw2d_source/fc2d_geoclaw_diagnostics_fort.f:      double precision error(meqn,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_local_ghost_pack_aux_fort.f:      double precision auxdata(maux,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_local_ghost_pack_aux_fort.f:         do j = 1-nghost,my-mint
fclaw2d_source/fc2d_geoclaw_local_ghost_pack_aux_fort.f:            do ibc = 1-nghost,mint
fclaw2d_source/fc2d_geoclaw_local_ghost_pack_aux_fort.f:         do jbc = 1-nghost,mint
fclaw2d_source/fc2d_geoclaw_local_ghost_pack_aux_fort.f:            do ibc = mx-mint+1,mx+nghost
fclaw2d_source/fc2d_geoclaw_local_ghost_pack_aux_fort.f:         do jbc = my-mint+1,my+nghost
fclaw2d_source/fc2d_geoclaw_local_ghost_pack_aux_fort.f:            do i = 1-nghost,mx-mint
fclaw2d_source/fc2d_geoclaw_local_ghost_pack_aux_fort.f:      kfinal = k - 1
fclaw2d_source/fc2d_geoclaw_copy_fort.f:c     # ----------------------------------------------------------
fclaw2d_source/fc2d_geoclaw_copy_fort.f:c     # Exchange routines - (mq,i,j) ordering
fclaw2d_source/fc2d_geoclaw_copy_fort.f:c     # ----------------------------------------------------------
fclaw2d_source/fc2d_geoclaw_copy_fort.f:c     # ----------------------------------------------------------
fclaw2d_source/fc2d_geoclaw_copy_fort.f:      double precision qthis(meqn,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_copy_fort.f:      double precision qneighbor(meqn,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_copy_fort.f:c                 # x-direction (idir == 0)
fclaw2d_source/fc2d_geoclaw_copy_fort.f:                     i1 = 1-ibc
fclaw2d_source/fc2d_geoclaw_copy_fort.f:c                 # y-direction (idir == 1)
fclaw2d_source/fc2d_geoclaw_copy_fort.f:                     j1 = 1-jbc
fclaw2d_source/fc2d_geoclaw_copy_fort.f:      double precision qthis(meqn,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_copy_fort.f:      double precision qneighbor(meqn,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_copy_fort.f:                  i1 = 1-ibc
fclaw2d_source/fc2d_geoclaw_copy_fort.f:                  j1 = 1-jbc
fclaw2d_source/fc2d_geoclaw_copy_fort.f:                  j1 = 1-jbc
fclaw2d_source/fc2d_geoclaw_copy_fort.f:                  i1 = 1 -ibc
fclaw2d_source/fc2d_geoclaw_copy_fort.f:      double precision qthis(meqn,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_copy_fort.f:      double precision qneighbor(meqn,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_copy_fort.f:                     qthis(mq,mx+ibc,jbc-mbc) =
fclaw2d_source/fc2d_geoclaw_copy_fort.f:     &                     qneighbor(mq,ibc,jbc-mbc)
fclaw2d_source/fc2d_geoclaw_copy_fort.f:                     qneighbor(mq,ibc-mbc,jbc-mbc) =
fclaw2d_source/fc2d_geoclaw_copy_fort.f:     &                     qthis(mq,mx+ibc-mbc,jbc-mbc)
fclaw2d_source/fc2d_geoclaw_copy_fort.f:                     qneighbor(mq,ibc-mbc,my+jbc) =
fclaw2d_source/fc2d_geoclaw_copy_fort.f:     &                     qthis(mq,mx+ibc-mbc,my+jbc)
fclaw2d_source/fc2d_geoclaw_copy_fort.f:                     qthis(mq,ibc-mbc,my+jbc) =
fclaw2d_source/fc2d_geoclaw_copy_fort.f:     &                     qneighbor(mq,ibc-mbc,jbc)
fclaw2d_source/fc2d_geoclaw_copy_fort.f:                     qneighbor(mq,ibc-mbc,jbc-mbc) =
fclaw2d_source/fc2d_geoclaw_copy_fort.f:     &                     qthis(mq,ibc-mbc,my+jbc-mbc)
fclaw2d_source/fc2d_geoclaw_copy_fort.f:                     qneighbor(mq,mx+ibc,jbc-mbc) =
fclaw2d_source/fc2d_geoclaw_copy_fort.f:     &                     qthis(mq,mx+ibc,my+jbc-mbc)
fclaw2d_source/fc2d_geoclaw_tag4coarsening_fort.f90:    DOUBLE PRECISION :: q0(meqn,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_tag4coarsening_fort.f90:    DOUBLE PRECISION :: q1(meqn,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_tag4coarsening_fort.f90:    DOUBLE PRECISION :: q2(meqn,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_tag4coarsening_fort.f90:    DOUBLE PRECISION :: q3(meqn,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_tag4coarsening_fort.f90:    DOUBLE PRECISION :: aux0(maux,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_tag4coarsening_fort.f90:    DOUBLE PRECISION :: aux1(maux,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_tag4coarsening_fort.f90:    DOUBLE PRECISION :: aux2(maux,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_tag4coarsening_fort.f90:    DOUBLE PRECISION :: aux3(maux,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_tag4coarsening_fort.f90:    DOUBLE PRECISION :: q(meqn,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_tag4coarsening_fort.f90:    DOUBLE PRECISION :: aux(maux,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_tag4coarsening_fort.f90:    !! If tag_patch_regions == 0 :  level < R.minlevel for some R; must refine --> can't coarsen
fclaw2d_source/fc2d_geoclaw_tag4coarsening_fort.f90:    !! If tag_patch_regions == 1 :  level > R.maxlevel for all R; can't refine --> must coarsen
fclaw2d_source/fc2d_geoclaw_tag4coarsening_fort.f90:    !! if tag_patch_regions == -1 : Inconclusive (use refinement criteria)
fclaw2d_source/fc2d_geoclaw_tag4coarsening_fort.f90:        yc   = ylower + (j - 0.5d0) * dy
fclaw2d_source/fc2d_geoclaw_tag4coarsening_fort.f90:            xc   = xlower + (i - 0.5d0) * dx
fclaw2d_source/fc2d_geoclaw_tag4coarsening_fort.f90:!!          # -1 : Not conclusive (possibly ghost cell) (do not tag for coarsening)
fclaw2d_source/fc2d_geoclaw_tag4coarsening_fort.f90:    tag_patch = -1  !! inconclusive
fclaw2d_source/fc2d_geoclaw_average_fort.f:c     > \param [in] idir     Face orientation - 0 for x-faces; 1 for y-faces
fclaw2d_source/fc2d_geoclaw_average_fort.f:c     [0-1]
fclaw2d_source/fc2d_geoclaw_average_fort.f:c     > \param [in] iface    Face number of fine grid [0-3].
fclaw2d_source/fc2d_geoclaw_average_fort.f:c     > \param [in] iface_coarse Face number of coarse grid [0-3].
fclaw2d_source/fc2d_geoclaw_average_fort.f:c     -1].
fclaw2d_source/fc2d_geoclaw_average_fort.f:      double precision qfine(meqn,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_average_fort.f:      double precision qcoarse(meqn,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_average_fort.f:      double precision aux_coarse(maux,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_average_fort.f:      double precision aux_fine(maux,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_average_fort.f:      integer i2(0:rr2-1),j2(0:rr2-1)
fclaw2d_source/fc2d_geoclaw_average_fort.f:      double precision af_sum, qv(0:rr2-1)
fclaw2d_source/fc2d_geoclaw_average_fort.f:                  ic = 1-ibc
fclaw2d_source/fc2d_geoclaw_average_fort.f:c              # ---------------------------------------------
fclaw2d_source/fc2d_geoclaw_average_fort.f:c              # Two 'half-size' neighbors will be passed into
fclaw2d_source/fc2d_geoclaw_average_fort.f:c              # have to be filled in by the other half-size
fclaw2d_source/fc2d_geoclaw_average_fort.f:c              # ---------------------------------------------
fclaw2d_source/fc2d_geoclaw_average_fort.f:               do m = 0,r2-1
fclaw2d_source/fc2d_geoclaw_average_fort.f:                        do m = 0,r2-1
fclaw2d_source/fc2d_geoclaw_average_fort.f:c                       # ----------------------------------------
fclaw2d_source/fc2d_geoclaw_average_fort.f:c                       # ----------------------------------------
fclaw2d_source/fc2d_geoclaw_average_fort.f:                     do m = 0,r2-1
fclaw2d_source/fc2d_geoclaw_average_fort.f:c                       hc=max(etaav-bc*capac,0.d0) !tsunamiclaw method
fclaw2d_source/fc2d_geoclaw_average_fort.f:                        hc=min(hav,(max(etaav-
fclaw2d_source/fc2d_geoclaw_average_fort.f:                  jc = 1-jbc
fclaw2d_source/fc2d_geoclaw_average_fort.f:               do m = 0,r2-1
fclaw2d_source/fc2d_geoclaw_average_fort.f:                        do m = 0,r2-1
fclaw2d_source/fc2d_geoclaw_average_fort.f:                     do m = 0,r2-1
fclaw2d_source/fc2d_geoclaw_average_fort.f:c                       hc=max(etaav-bc*capac,0.d0) !tsunamiclaw method
fclaw2d_source/fc2d_geoclaw_average_fort.f:                        hc=min(hav,(max(etaav-
fclaw2d_source/fc2d_geoclaw_average_fort.f:c                     do m = 0,r2-1
fclaw2d_source/fc2d_geoclaw_average_fort.f:      double precision qcoarse(meqn,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_average_fort.f:      double precision qfine(meqn,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_average_fort.f:      double precision aux_coarse(maux,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_average_fort.f:      double precision aux_fine(maux,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_average_fort.f:      integer i2(0:rr2-1),j2(0:rr2-1)
fclaw2d_source/fc2d_geoclaw_average_fort.f:    1          i1 = 1-ibc
fclaw2d_source/fc2d_geoclaw_average_fort.f:               j1 = 1-jbc
fclaw2d_source/fc2d_geoclaw_average_fort.f:               j1 = 1-jbc
fclaw2d_source/fc2d_geoclaw_average_fort.f:               i1 = 1-ibc
fclaw2d_source/fc2d_geoclaw_average_fort.f:                  do m = 0,r2-1
fclaw2d_source/fc2d_geoclaw_average_fort.f:               do m = 0,r2-1
fclaw2d_source/fc2d_geoclaw_average_fort.f:c                       hc=max(etaav-bc*capac,0.d0) !tsunamiclaw method
fclaw2d_source/fc2d_geoclaw_average_fort.f:                  hc = min(hav,(max(etaav-
fclaw2d_source/fc2d_geoclaw_average_fort.f:c                  do m = 0,r2-1
fclaw2d_source/fc2d_geoclaw_average_fort.f:      double precision qcoarse(meqn,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_average_fort.f:      double precision qfine(meqn,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_average_fort.f:      double precision aux_coarse(maux,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_average_fort.f:      double precision aux_fine(maux,1-mbc:mx+mbc,1-mbc:my+mbc)
fclaw2d_source/fc2d_geoclaw_average_fort.f:      integer i2(0:rr2-1),j2(0:rr2-1)
fclaw2d_source/fc2d_geoclaw_average_fort.f:      jg = (igrid-ig)/refratio
fclaw2d_source/fc2d_geoclaw_average_fort.f:                  i2(m) = (i-1)*refratio + ii
fclaw2d_source/fc2d_geoclaw_average_fort.f:                  j2(m) = (j-1)*refratio + jj
fclaw2d_source/fc2d_geoclaw_average_fort.f:            do m = 0,r2-1
fclaw2d_source/fc2d_geoclaw_average_fort.f:c              hc=max(etaav-bc*capac,0.d0) !tsunamiclaw method
fclaw2d_source/fc2d_geoclaw_average_fort.f:               hc=min(hav,(max(etaav-
fclaw2d_source/fc2d_geoclaw_test_regions.f90:    tag_patch = -1  !!  Inconclusive for now.
fclaw2d_source/fc2d_geoclaw_test_regions.f90:        tag_patch = -1
fortran_source/geoclaw_flux2fw_fort.f:c--------------------------------------------------------------------
fortran_source/geoclaw_flux2fw_fort.f:c--------------------------------------------------------------------
fortran_source/geoclaw_flux2fw_fort.f:c     # we are solving along a 1D slice in the x-direction.
fortran_source/geoclaw_flux2fw_fort.f:c        The jump in q (q1d(i,:)-q1d(i-1,:))  is split by rpn2 into
fortran_source/geoclaw_flux2fw_fort.f:c            amdq =  the left-going flux difference  A^- Delta q
fortran_source/geoclaw_flux2fw_fort.f:c            apdq = the right-going flux difference  A^+ Delta q
fortran_source/geoclaw_flux2fw_fort.f:c            bmasdq = the down-going transverse flux difference B^- A^* Delta q
fortran_source/geoclaw_flux2fw_fort.f:c            bpasdq =   the up-going transverse flux difference B^+ A^* Delta q
fortran_source/geoclaw_flux2fw_fort.f:c        where A^* represents either A^- or A^+.
fortran_source/geoclaw_flux2fw_fort.f:c--------------------------flux2fw_geo.f--------------------------
fortran_source/geoclaw_flux2fw_fort.f:c     step2_geo.f  The only modification is for the first-order
fortran_source/geoclaw_flux2fw_fort.f:c---------------------last modified 1/04/05-----------------------------
fortran_source/geoclaw_flux2fw_fort.f:      implicit double precision (a-h,o-z)
fortran_source/geoclaw_flux2fw_fort.f:      dimension  q1d(meqn, 1-mbc:maxm+mbc)
fortran_source/geoclaw_flux2fw_fort.f:      dimension  bmasdq(meqn, 1-mbc:maxm+mbc)
fortran_source/geoclaw_flux2fw_fort.f:      dimension  bpasdq(meqn, 1-mbc:maxm+mbc)
fortran_source/geoclaw_flux2fw_fort.f:      dimension  cqxx(meqn, 1-mbc:maxm+mbc)
fortran_source/geoclaw_flux2fw_fort.f:      dimension  faddm(meqn,1-mbc:maxm+mbc)
fortran_source/geoclaw_flux2fw_fort.f:      dimension  faddp(meqn,1-mbc:maxm+mbc)
fortran_source/geoclaw_flux2fw_fort.f:      dimension  gaddm(meqn,1-mbc:maxm+mbc, 2)
fortran_source/geoclaw_flux2fw_fort.f:      dimension  gaddp(meqn,1-mbc:maxm+mbc, 2)
fortran_source/geoclaw_flux2fw_fort.f:      dimension  dtdx1d(1-mbc:maxm+mbc)
fortran_source/geoclaw_flux2fw_fort.f:      dimension  aux1(maux, 1-mbc:maxm+mbc)
fortran_source/geoclaw_flux2fw_fort.f:      dimension  aux2(maux, 1-mbc:maxm+mbc)
fortran_source/geoclaw_flux2fw_fort.f:      dimension  aux3(maux, 1-mbc:maxm+mbc)
fortran_source/geoclaw_flux2fw_fort.f:      dimension  s(mwaves, 1-mbc:maxm+mbc)
fortran_source/geoclaw_flux2fw_fort.f:      dimension  fwave(meqn, mwaves, 1-mbc:maxm+mbc)
fortran_source/geoclaw_flux2fw_fort.f:      dimension  amdq(meqn, 1-mbc:maxm+mbc)
fortran_source/geoclaw_flux2fw_fort.f:      dimension  apdq(meqn, 1-mbc:maxm+mbc)
fortran_source/geoclaw_flux2fw_fort.f:c     -----------------------------
fortran_source/geoclaw_flux2fw_fort.f:        do 20 i = 1-mbc, mx+mbc
fortran_source/geoclaw_flux2fw_fort.f:c     ---------------------------------------------------------------------
fortran_source/geoclaw_flux2fw_fort.f:c   # Set fadd for the donor-cell upwind method (Godunov)
fortran_source/geoclaw_flux2fw_fort.f:      do 40 i=1-mbc+1,mx+mbc-1
fortran_source/geoclaw_flux2fw_fort.f:            faddp(m,i) = faddp(m,i) - apdq(m,i)
fortran_source/geoclaw_flux2fw_fort.f:c          # if s<0 use dtdx1d(i-1) to compute CFL:
fortran_source/geoclaw_flux2fw_fort.f:     &                          -dtdx1d(i-1)*s(mw,i))
fortran_source/geoclaw_flux2fw_fort.f:c     -----------------------------------------------------------
fortran_source/geoclaw_flux2fw_fort.f:c        # i-1 and i.  Compute these and overwrite dtdx1d:
fortran_source/geoclaw_flux2fw_fort.f:         dtdx1d(i-1) = 0.5d0 * (dtdx1d(i-1) + dtdx1d(i))
fortran_source/geoclaw_flux2fw_fort.f:     &            * (1.d0 - dabs(s(mw,i))*dtdx1d(i-1)) * fwave(m,mw,i)
fortran_source/geoclaw_flux2fw_fort.f:                apdq(m,i) = apdq(m,i) - cqxx(m,i)
fortran_source/geoclaw_flux2fw_fort.f:c      --------------------------------------------
fortran_source/geoclaw_flux2fw_fort.f:c     # split the left-going flux difference into down-going and up-going:
fortran_source/geoclaw_flux2fw_fort.f:c     # modify flux below and above by B^- A^- Delta q and  B^+ A^- Delta q:
fortran_source/geoclaw_flux2fw_fort.f:               gupdate = 0.5d0*dtdx1d(i-1) * bmasdq(m,i)
fortran_source/geoclaw_flux2fw_fort.f:               gaddm(m,i-1,1) = gaddm(m,i-1,1) - gupdate
fortran_source/geoclaw_flux2fw_fort.f:               gaddp(m,i-1,1) = gaddp(m,i-1,1) - gupdate
fortran_source/geoclaw_flux2fw_fort.f:               gupdate = 0.5d0*dtdx1d(i-1) * bpasdq(m,i)
fortran_source/geoclaw_flux2fw_fort.f:               gaddm(m,i-1,2) = gaddm(m,i-1,2) - gupdate
fortran_source/geoclaw_flux2fw_fort.f:               gaddp(m,i-1,2) = gaddp(m,i-1,2) - gupdate
fortran_source/geoclaw_flux2fw_fort.f:c     # split the right-going flux difference into down-going and up-going:
fortran_source/geoclaw_flux2fw_fort.f:c     # modify flux below and above by B^- A^+ Delta q and  B^+ A^+ Delta q:
fortran_source/geoclaw_flux2fw_fort.f:               gupdate = 0.5d0*dtdx1d(i-1) * bmasdq(m,i)
fortran_source/geoclaw_flux2fw_fort.f:               gaddm(m,i,1) = gaddm(m,i,1) - gupdate
fortran_source/geoclaw_flux2fw_fort.f:               gaddp(m,i,1) = gaddp(m,i,1) - gupdate
fortran_source/geoclaw_flux2fw_fort.f:               gupdate = 0.5d0*dtdx1d(i-1) * bpasdq(m,i)
fortran_source/geoclaw_flux2fw_fort.f:               gaddm(m,i,2) = gaddm(m,i,2) - gupdate
fortran_source/geoclaw_flux2fw_fort.f:               gaddp(m,i,2) = gaddp(m,i,2) - gupdate
fortran_source/geoclaw_step2_fort.f90:!------------------step2_geo.f-----------------------
fortran_source/geoclaw_step2_fort.f90:!------------last modified 12/30/04--------------------------
fortran_source/geoclaw_step2_fort.f90:    real(kind=8), intent(inout) :: qold(meqn, 1-mbc:mx+mbc, 1-mbc:my+mbc)
fortran_source/geoclaw_step2_fort.f90:    real(kind=8), intent(inout) :: aux(maux,1-mbc:mx+mbc, 1-mbc:my+mbc)
fortran_source/geoclaw_step2_fort.f90:    real(kind=8), intent(inout) :: fm(meqn, 1-mbc:mx+mbc, 1-mbc:my+mbc)
fortran_source/geoclaw_step2_fort.f90:    real(kind=8), intent(inout) :: fp(meqn,1-mbc:mx+mbc, 1-mbc:my+mbc)
fortran_source/geoclaw_step2_fort.f90:    real(kind=8), intent(inout) :: gm(meqn,1-mbc:mx+mbc, 1-mbc:my+mbc)
fortran_source/geoclaw_step2_fort.f90:    real(kind=8), intent(inout) :: gp(meqn,1-mbc:mx+mbc, 1-mbc:my+mbc)
fortran_source/geoclaw_step2_fort.f90:    real(kind=8) :: faddm(meqn,1-mbc:maxm+mbc)
fortran_source/geoclaw_step2_fort.f90:    real(kind=8) :: faddp(meqn,1-mbc:maxm+mbc)
fortran_source/geoclaw_step2_fort.f90:    real(kind=8) :: gaddm(meqn,1-mbc:maxm+mbc,2)
fortran_source/geoclaw_step2_fort.f90:    real(kind=8) :: gaddp(meqn,1-mbc:maxm+mbc,2)
fortran_source/geoclaw_step2_fort.f90:    real(kind=8) ::  q1d(meqn,1-mbc:maxm+mbc)
fortran_source/geoclaw_step2_fort.f90:    real(kind=8) :: aux1(maux,1-mbc:maxm+mbc)
fortran_source/geoclaw_step2_fort.f90:    real(kind=8) :: aux2(maux,1-mbc:maxm+mbc)
fortran_source/geoclaw_step2_fort.f90:    real(kind=8) :: aux3(maux,1-mbc:maxm+mbc)
fortran_source/geoclaw_step2_fort.f90:    real(kind=8) :: dtdx1d(1-mbc:maxm+mbc)
fortran_source/geoclaw_step2_fort.f90:    real(kind=8) :: dtdy1d(1-mbc:maxm+mbc)
fortran_source/geoclaw_step2_fort.f90: !   real(kind=8) ::  wave(meqn, mwaves, 1-mbc:maxm+mbc)
fortran_source/geoclaw_step2_fort.f90: !   real(kind=8) ::     s(mwaves, 1-mbc:maxm + mbc)
fortran_source/geoclaw_step2_fort.f90: !   real(kind=8) ::  amdq(meqn,1-mbc:maxm + mbc)
fortran_source/geoclaw_step2_fort.f90: !   real(kind=8) ::  apdq(meqn,1-mbc:maxm + mbc)
fortran_source/geoclaw_step2_fort.f90:!     real(kind=8) ::  cqxx(meqn,1-mbc:maxm + mbc)
fortran_source/geoclaw_step2_fort.f90:!     real(kind=8) :: bmadq(meqn,1-mbc:maxm + mbc)
fortran_source/geoclaw_step2_fort.f90:!     real(kind=8) :: bpadq(meqn,1-mbc:maxm + mbc)
fortran_source/geoclaw_step2_fort.f90:    ! Perform X-Sweeps
fortran_source/geoclaw_step2_fort.f90:       q1d(:,1-mbc:mx+mbc) = qold(:,1-mbc:mx+mbc,j)
fortran_source/geoclaw_step2_fort.f90:                   q1d(m,1-ibc) = qold(m,ibc,0)
fortran_source/geoclaw_step2_fort.f90:                   q1d(m,mx+ibc) = qold(m,mx-ibc+1,0)
fortran_source/geoclaw_step2_fort.f90:                   q1d(m,1-ibc) = qold(m,ibc,my+1)
fortran_source/geoclaw_step2_fort.f90:                   q1d(m,mx+ibc) = qold(m,mx-ibc+1,my+1)
fortran_source/geoclaw_step2_fort.f90:            dtdx1d(1-mbc:mx+mbc) = dtdx / aux(mcapa,1-mbc:mx+mbc,j)
fortran_source/geoclaw_step2_fort.f90:            aux1(:,1-mbc:mx+mbc) = aux(:,1-mbc:mx+mbc,j-1)
fortran_source/geoclaw_step2_fort.f90:            aux2(:,1-mbc:mx+mbc) = aux(:,1-mbc:mx+mbc,j  )
fortran_source/geoclaw_step2_fort.f90:            aux3(:,1-mbc:mx+mbc) = aux(:,1-mbc:mx+mbc,j+1)
fortran_source/geoclaw_step2_fort.f90:        ! write(53,*) 'x-sweep: ',cfl1d,cflgrid
fortran_source/geoclaw_step2_fort.f90:    !  y-sweeps
fortran_source/geoclaw_step2_fort.f90:       q1d(:,1-mbc:my+mbc) = qold(:,i,1-mbc:my+mbc)
fortran_source/geoclaw_step2_fort.f90:                   q1d(m,1-jbc) = qold(m,0,jbc)
fortran_source/geoclaw_step2_fort.f90:                   q1d(m,my+jbc) = qold(m,0,my-jbc+1)
fortran_source/geoclaw_step2_fort.f90:                   q1d(m,1-jbc) = qold(m,mx+1,jbc)
fortran_source/geoclaw_step2_fort.f90:                   q1d(m,my+jbc) = qold(m,mx+1,my-jbc+1)
fortran_source/geoclaw_step2_fort.f90:            dtdy1d(1-mbc:my+mbc) = dtdy / aux(mcapa,i,1-mbc:my+mbc)
fortran_source/geoclaw_step2_fort.f90:            aux1(:,1-mbc:my+mbc) = aux(:,i-1,1-mbc:my+mbc)
fortran_source/geoclaw_step2_fort.f90:            aux2(:,1-mbc:my+mbc) = aux(:,i,1-mbc:my+mbc)
fortran_source/geoclaw_step2_fort.f90:            aux3(:,1-mbc:my+mbc) = aux(:,i+1,1-mbc:my+mbc)
fortran_source/geoclaw_step2_fort.f90:        ! write(53,*) 'y-sweep: ',cfl1d,cflgrid
fortran_source/geoclaw_step2_fort.f90:                  - min(0.d0,dtdxij*fp(1,i,j)) - min(0.d0,dtdyij*gp(1,i,j))
fortran_source/geoclaw_step2_fort.f90:                            cm = fp(m,i,j) - fm(m,i,j)
fortran_source/geoclaw_step2_fort.f90:                            cm = gp(m,i,j) - gm(m,i,j)
fortran_source/geoclaw_step2_fort.f90:                            cm = fp(m,i+1,j) - fm(m,i+1,j)
fortran_source/geoclaw_step2_fort.f90:                            fm(m,i+1,j) = fp(m,i+1,j) - cm
fortran_source/geoclaw_step2_fort.f90:                            cm = gp(m,i,j+1) - gm(m,i,j+1)
fortran_source/geoclaw_step2_fort.f90:                            gm(m,i,j+1) = gp(m,i,j+1) - cm
fortran_source/geoclaw_setaux_fort.f90:  !!     If coordinate_system=2 then lat-lon coordinates on the sphere and
fortran_source/geoclaw_setaux_fort.f90:  !!        aux(2,i,j) = area ratio (capacity function -- set mcapa = 2)
fortran_source/geoclaw_setaux_fort.f90:  REAL(kind=8), INTENT(inout) :: aux(maux,1-mbc:mx+mbc,1-mbc:my+mbc)
fortran_source/geoclaw_setaux_fort.f90:  !! Lat-Long coordinate system in use, check input variables
fortran_source/geoclaw_setaux_fort.f90:  !! Check below is new in 5.2.1 -- need to rethink for storm surge
fortran_source/geoclaw_setaux_fort.f90:        !! for some reason it bombs, e.g. in bowl-radial if maux>1.
fortran_source/geoclaw_setaux_fort.f90:        do jj = 1-mbc,my+mbc
fortran_source/geoclaw_setaux_fort.f90:          do ii = 1-mbc,mx+mbc
fortran_source/geoclaw_setaux_fort.f90:    do jj = 1-mbc,my+mbc
fortran_source/geoclaw_setaux_fort.f90:      do ii = 1-mbc,mx+mbc
fortran_source/geoclaw_setaux_fort.f90:    do jj = 1-mbc,my+mbc
fortran_source/geoclaw_setaux_fort.f90:      do ii = 1-mbc,mx+mbc
fortran_source/geoclaw_setaux_fort.f90:    do jj = 1-mbc,my+mbc
fortran_source/geoclaw_setaux_fort.f90:      do ii = 1-mbc,mx+mbc
fortran_source/geoclaw_setaux_fort.f90:    do jj = 1-mbc,my+mbc
fortran_source/geoclaw_setaux_fort.f90:      do ii = 1-mbc,mx+mbc
fortran_source/geoclaw_setaux_fort.f90:!!        aux(1,ii,jj) = test_topo(xlow + (ii - 0.5d0) * dx,       &
fortran_source/geoclaw_setaux_fort.f90:!!            ylow + (jj - 0.5d0) * dy)
fortran_source/geoclaw_setaux_fort.f90:          aux(1,ii,jj) = test_topo(xlow + (ii - 0.5d0) * dx)
fortran_source/geoclaw_setaux_fort.f90:  ilo = FLOOR((xlow - xlower + .05d0*dx)/dx)
fortran_source/geoclaw_setaux_fort.f90:  jlo = FLOOR((ylow - ylower + .05d0*dy)/dy)
fortran_source/geoclaw_setaux_fort.f90:  DO jj=1-mbc,my+mbc
fortran_source/geoclaw_setaux_fort.f90:     !!ym = ylow + (jj - 1.d0) * dy
fortran_source/geoclaw_setaux_fort.f90:     !!y = ylow + (jj - 0.5d0) * dy
fortran_source/geoclaw_setaux_fort.f90:     ym = ylower + (jlo+jj-1.d0) * dy
fortran_source/geoclaw_setaux_fort.f90:     DO ii=1-mbc,mx+mbc
fortran_source/geoclaw_setaux_fort.f90:        !!xm = xlow + (ii - 1.d0) * dx
fortran_source/geoclaw_setaux_fort.f90:        !!x  = xlow + (ii - 0.5d0) * dx
fortran_source/geoclaw_setaux_fort.f90:        xm = xlower + (ilo+ii-1.d0) * dx
fortran_source/geoclaw_setaux_fort.f90:        !! Set lat-long cell info
fortran_source/geoclaw_setaux_fort.f90:           aux(2,ii,jj) = deg2rad * earth_radius**2 * (SIN(yp * deg2rad) - SIN(ym * deg2rad)) / dy
fortran_source/geoclaw_setaux_fort.f90:  DO jj=1-mbc,my+mbc
fortran_source/geoclaw_setaux_fort.f90:     y = ylower + (jlo+jj-.5d0) * dy
fortran_source/geoclaw_setaux_fort.f90:        DO ii=1-mbc,mx+mbc
fortran_source/geoclaw_setaux_fort.f90:           x = xlower + (ilo+ii-.5d0) * dx
fortran_source/geoclaw_setaux_fort.f90:           iint = ii + MAX(0, CEILING((xlower-x)/dx)) &
fortran_source/geoclaw_setaux_fort.f90:                - MAX(0, CEILING((x-xupper)/dx))
fortran_source/geoclaw_setaux_fort.f90:           jint = jj + MAX(0, CEILING((ylower-y)/dy)) &
fortran_source/geoclaw_setaux_fort.f90:                - MAX(0, CEILING((y-yupper)/dy))
fortran_source/geoclaw_setaux_fort.f90:  DO ii=1-mbc,mx+mbc
fortran_source/geoclaw_setaux_fort.f90:     x =  xlower + (ilo+ii-.5d0) * dx
fortran_source/geoclaw_setaux_fort.f90:        DO jj=1-mbc,my+mbc
fortran_source/geoclaw_setaux_fort.f90:           y = ylower + (jlo+jj-.5d0) * dy
fortran_source/geoclaw_setaux_fort.f90:           iint = ii + MAX(0, CEILING((xlower-x)/dx)) &
fortran_source/geoclaw_setaux_fort.f90:                - MAX(0, CEILING((x-xupper)/dx))
fortran_source/geoclaw_setaux_fort.f90:           jint = jj + MAX(0, CEILING((ylower-y)/dy)) &
fortran_source/geoclaw_setaux_fort.f90:                - MAX(0, CEILING((y-yupper)/dy))
fortran_source/geoclaw_setaux_fort.f90:     DO jj=1-mbc,my+mbc
fortran_source/geoclaw_setaux_fort.f90:        DO ii=1-mbc,mx+mbc
fortran_source/geoclaw_setaux_fort.f90:           x = xlow + (ii-0.5d0)*dx
fortran_source/geoclaw_setaux_fort.f90:           y = ylow + (jj-0.5d0)*dy
fortran_source/geoclaw_setaux_fort.f90:  inner = (i .gt. mint .and. i .lt. mx-mint+1) .and. &
fortran_source/geoclaw_setaux_fort.f90:          (j .gt. mint .and. j .lt. my-mint+1)
fortran_source/geoclaw_setaux_fort.f90:  outer = (i .lt. 1-nghost) .or. (i .gt. mx+nghost) .or. &
fortran_source/geoclaw_setaux_fort.f90:          (j .lt. 1-nghost) .or. (j .gt. my+nghost)
fortran_source/geoclaw_src2_fort.f90:  double precision, intent(inout) :: q(meqn,1-mbc:mx+mbc,1-mbc:my+mbc)
fortran_source/geoclaw_src2_fort.f90:  double precision, intent(inout) :: aux(maux,1-mbc:mx+mbc,1-mbc:my+mbc)
fortran_source/geoclaw_src2_fort.f90:  real(kind=8), parameter :: depth_tolerance = 1.0d-30
fortran_source/geoclaw_src2_fort.f90:                    do nman = num_manning, 1, -1
fortran_source/geoclaw_src2_fort.f90:        y = ylower + (j - 0.5d0) * dy
fortran_source/geoclaw_src2_fort.f90:        a(1,1) = 1.d0 - 0.5d0 * fdt**2 + fdt**4 / 24.d0
fortran_source/geoclaw_src2_fort.f90:        a(1,2) =  fdt - fdt**3 / 6.d0
fortran_source/geoclaw_src2_fort.f90:        a(2,1) = -fdt + fdt**3 / 6.d0
fortran_source/geoclaw_src2_fort.f90:  !! wind -----------------------------------------------------------
fortran_source/geoclaw_src2_fort.f90:        yc = ylower + (j - 0.5d0) * dy
fortran_source/geoclaw_src2_fort.f90:           xc = xlower + (i - 0.5d0) * dx
fortran_source/geoclaw_src2_fort.f90:              psi = atan2(yc - sloc(2), xc - sloc(1))
fortran_source/geoclaw_src2_fort.f90:                 phi = (2.d0 * pi - theta + psi) * RAD2DEG
fortran_source/geoclaw_src2_fort.f90:                 phi = (psi - theta) * RAD2DEG
fortran_source/geoclaw_src2_fort.f90:  !! ----------------------------------------------------------------
fortran_source/geoclaw_src2_fort.f90:  !! Atmosphere Pressure --------------------------------------------
fortran_source/geoclaw_src2_fort.f90:        ym = ylower + (j - 1.d0) * dy
fortran_source/geoclaw_src2_fort.f90:        yc = ylower + (j - 0.5d0) * dy
fortran_source/geoclaw_src2_fort.f90:           xm = xlower + (i - 1.d0) * dx
fortran_source/geoclaw_src2_fort.f90:           xc = xlower + (i - 0.5d0) * dx
fortran_source/geoclaw_src2_fort.f90:              !! Convert distance in lat-long to meters
fortran_source/geoclaw_src2_fort.f90:                - aux(pressure_index,i-1,j)) / (2.d0 * dx_meters)
fortran_source/geoclaw_src2_fort.f90:                - aux(pressure_index,i,j-1)) / (2.d0 * dy_meters)
fortran_source/geoclaw_src2_fort.f90:              q(2, i, j) = q(2, i, j) - dt * h * P_gradient(1) / rho
fortran_source/geoclaw_src2_fort.f90:              q(3, i, j) = q(3, i, j) - dt * h * P_gradient(2) / rho
fortran_source/philim.f:      implicit double precision (a-h,o-z)
fortran_source/philim.f:c     --------
fortran_source/philim.f:c     --------
fortran_source/philim.f:c     ----------
fortran_source/philim.f:c     ----------
fortran_source/philim.f:c     ----------
fortran_source/philim.f:c     ----------
fortran_source/philim.f:c     ------------------------------
fortran_source/philim.f:c     ------------------------------
fortran_source/philim.f:c     ------------------------------
fortran_source/philim.f:c     # Beam-Warming
fortran_source/philim.f:c     ------------------------------
fortran_source/geoclaw_step2_wrap_fort.f:      double precision qold(meqn, 1-mbc:mx+mbc, 1-mbc:my+mbc)
fortran_source/geoclaw_step2_wrap_fort.f:      double precision aux(maux, 1-mbc:mx+mbc, 1-mbc:my+mbc)
fortran_source/geoclaw_step2_wrap_fort.f:      double precision fp(meqn,1-mbc:mx+mbc,1-mbc:my+mbc)
fortran_source/geoclaw_step2_wrap_fort.f:      double precision fm(meqn,1-mbc:mx+mbc,1-mbc:my+mbc)
fortran_source/geoclaw_step2_wrap_fort.f:      double precision gp(meqn,1-mbc:mx+mbc,1-mbc:my+mbc)
fortran_source/geoclaw_step2_wrap_fort.f:      double precision gm(meqn,1-mbc:mx+mbc,1-mbc:my+mbc)
fortran_source/geoclaw_step2_wrap_fort.f:c      mused   = i0next - 1                    !# space already used
fortran_source/geoclaw_step2_wrap_fort.f:c      mwork1  = mwork - mused           !# remaining space (passed to step2)
fortran_source/geoclaw_step2_wrap_fort.f:     &                  - dtdx * (fm(m,i+1,j) - fp(m,i,j))
fortran_source/geoclaw_step2_wrap_fort.f:     &                  - dtdy * (gm(m,i,j+1) - gp(m,i,j))
fortran_source/geoclaw_step2_wrap_fort.f:     &                  -(dtdx*(fm(m,i+1,j) - fp(m,i,j))
fortran_source/geoclaw_step2_wrap_fort.f:     &                  + dtdy*(gm(m,i,j+1) - gp(m,i,j)))/aux(mcapa,i,j)
fortran_source/geoclaw_b4step2_fort.f90:    !! # use to set time-dependent aux arrays or perform other tasks.
fortran_source/geoclaw_b4step2_fort.f90:    REAL(kind=8), INTENT(inout) :: q(meqn,1-mbc:mx+mbc,1-mbc:my+mbc)
fortran_source/geoclaw_b4step2_fort.f90:    REAL(kind=8), INTENT(inout) :: aux(maux,1-mbc:mx+mbc,1-mbc:my+mbc)
fortran_source/geoclaw_b4step2_fort.f90:    FORALL(i=1-mbc:mx+mbc, j=1-mbc:my+mbc,q(1,i,j) < dry_tolerance)
fortran_source/geoclaw_b4step2_fort.f90:        tau = (t - tmin)/(tmax-tmin)
fortran_source/geoclaw_b4step2_fort.f90:            tau = -1
fortran_source/geoclaw_gauges_fort.f90:    real(kind=8) :: q(meqn, 1-mbc:mx+mbc, 1-mbc:my+mbc)
fortran_source/geoclaw_gauges_fort.f90:    real(kind=8) :: aux(maux, 1-mbc:mx+mbc, 1-mbc:my+mbc)
fortran_source/geoclaw_gauges_fort.f90:    iindex =  int((xc-xlower)/dx) + 1
fortran_source/geoclaw_gauges_fort.f90:    jindex =  int((yc-ylower)/dy) + 1
fortran_source/geoclaw_gauges_fort.f90:    xcent  = xlower + (iindex-.5d0)*dx
fortran_source/geoclaw_gauges_fort.f90:    ycent  = ylower + (jindex-.5d0)*dy
fortran_source/geoclaw_gauges_fort.f90:    xoff   = (xc-xcent)/dx
fortran_source/geoclaw_gauges_fort.f90:    yoff   = (yc-ycent)/dy
fortran_source/geoclaw_gauges_fort.f90:        !! icell = int(1.d0 + (xc - xlower) / hx)
fortran_source/geoclaw_gauges_fort.f90:        !! jcell = int(1.d0 + (yc - ylower) / hy)
fortran_source/geoclaw_gauges_fort.f90:            qvar(mq) = (1.d0 - xoff) * (1.d0 - yoff) &
fortran_source/geoclaw_gauges_fort.f90:                + xoff*(1.d0 - yoff) * q(mq,iindex+1,jindex)  &
fortran_source/geoclaw_gauges_fort.f90:                + (1.d0 - xoff) * yoff * q(mq,iindex,jindex+1)  &
fortran_source/geoclaw_gauges_fort.f90:        topo = (1.d0 - xoff) * (1.d0 - yoff)  &
fortran_source/geoclaw_gauges_fort.f90:                  + xoff * (1.d0 - yoff) * aux(1,iindex+1,jindex)  &
fortran_source/geoclaw_gauges_fort.f90:                  + (1.d0 - xoff) * yoff * aux(1,iindex,jindex+1)  &
fortran_source/geoclaw_gauges_fort.f90:        if (abs(qvar(mq)) < 1d-99) qvar(mq) = 0.d0
fortran_source/geoclaw_gauges_fort.f90:    !! if (abs(eta) < 1d-99) eta = 0.d0
fortran_source/geoclaw_limiter_fort.f:c     # The limiter is computed by comparing the 2-norm of each wave with
fortran_source/geoclaw_limiter_fort.f:c     # given by dotl/wnorm2 and dotr/wnorm2, where wnorm2 is the 2-norm
fortran_source/geoclaw_limiter_fort.f:      implicit double precision (a-h,o-z)
fortran_source/geoclaw_limiter_fort.f:      dimension wave(meqn, mwaves, 1-mbc:maxm+mbc)
fortran_source/geoclaw_limiter_fort.f:      dimension    s(mwaves, 1-mbc:maxm+mbc)
fortran_source/geoclaw_bc2_fort.f:c     #   mthbc(k) =  0  for user-supplied BC's (must be inserted!)
fortran_source/geoclaw_bc2_fort.f:c     #            =  1  for zero-order extrapolation
fortran_source/geoclaw_bc2_fort.f:c     ------------------------------------------------
fortran_source/geoclaw_bc2_fort.f:c     #   (i, 1-jbc)   for jbc = 1,mbc,  i = 1-mbc, mx+mbc
fortran_source/geoclaw_bc2_fort.f:c     #   (i, my+jbc)  for jbc = 1,mbc,  i = 1-mbc, mx+mbc
fortran_source/geoclaw_bc2_fort.f:c     #   (1-ibc, j)   for ibc = 1,mbc,  j = 1-mbc, my+mbc
fortran_source/geoclaw_bc2_fort.f:c     #   (mx+ibc, j)  for ibc = 1,mbc,  j = 1-mbc, my+mbc
fortran_source/geoclaw_bc2_fort.f:      double precision q(meqn,1-mbc:mx+mbc, 1-mbc:my+mbc)
fortran_source/geoclaw_bc2_fort.f:      double precision aux(maux,1-mbc:mx+mbc, 1-mbc:my+mbc)
fortran_source/geoclaw_bc2_fort.f:c-------------------------------------------------------
fortran_source/geoclaw_bc2_fort.f:c-------------------------------------------------------
fortran_source/geoclaw_bc2_fort.f:c     # user-specified boundary conditions go here in place of error output
fortran_source/geoclaw_bc2_fort.f:c     # zero-order extrapolation:
fortran_source/geoclaw_bc2_fort.f:      do 115 j = 1-mbc, my+mbc
fortran_source/geoclaw_bc2_fort.f:            aux(1,1-ibc,j) = aux(1,1,j)
fortran_source/geoclaw_bc2_fort.f:               q(m,1-ibc,j) = q(m,1,j)
fortran_source/geoclaw_bc2_fort.f:      do 135 j = 1-mbc, my+mbc
fortran_source/geoclaw_bc2_fort.f:            aux(1,1-ibc,j) = aux(1,ibc,j)
fortran_source/geoclaw_bc2_fort.f:               q(m,1-ibc,j) = q(m,ibc,j)
fortran_source/geoclaw_bc2_fort.f:      do 136 j = 1-mbc, my+mbc
fortran_source/geoclaw_bc2_fort.f:            q(2,1-ibc,j) = -q(2,ibc,j)
fortran_source/geoclaw_bc2_fort.f:c-------------------------------------------------------
fortran_source/geoclaw_bc2_fort.f:c-------------------------------------------------------
fortran_source/geoclaw_bc2_fort.f:c     # user-specified boundary conditions go here in place of error output
fortran_source/geoclaw_bc2_fort.f:c     # zero-order extrapolation:
fortran_source/geoclaw_bc2_fort.f:      do 215 j = 1-mbc, my+mbc
fortran_source/geoclaw_bc2_fort.f:      do 235 j = 1-mbc, my+mbc
fortran_source/geoclaw_bc2_fort.f:            aux(1,mx+ibc,j) = aux(1,mx+1-ibc,j)
fortran_source/geoclaw_bc2_fort.f:               q(m,mx+ibc,j) = q(m,mx+1-ibc,j)
fortran_source/geoclaw_bc2_fort.f:      do 236 j = 1-mbc, my+mbc
fortran_source/geoclaw_bc2_fort.f:            q(2,mx+ibc,j) = -q(2,mx+1-ibc,j)
fortran_source/geoclaw_bc2_fort.f:c-------------------------------------------------------
fortran_source/geoclaw_bc2_fort.f:c-------------------------------------------------------
fortran_source/geoclaw_bc2_fort.f:c     # user-specified boundary conditions go here in place of error output
fortran_source/geoclaw_bc2_fort.f:c     # zero-order extrapolation:
fortran_source/geoclaw_bc2_fort.f:         do 315 i = 1-mbc, mx+mbc
fortran_source/geoclaw_bc2_fort.f:            aux(1,i,1-jbc) = aux(1,i,1)
fortran_source/geoclaw_bc2_fort.f:               q(m,i,1-jbc) = q(m,i,1)
fortran_source/geoclaw_bc2_fort.f:         do 335 i = 1-mbc, mx+mbc
fortran_source/geoclaw_bc2_fort.f:            aux(1,i,1-jbc) = aux(1,i,jbc)
fortran_source/geoclaw_bc2_fort.f:               q(m,i,1-jbc) = q(m,i,jbc)
fortran_source/geoclaw_bc2_fort.f:         do 336 i = 1-mbc, mx+mbc
fortran_source/geoclaw_bc2_fort.f:            q(3,i,1-jbc) = -q(3,i,jbc)
fortran_source/geoclaw_bc2_fort.f:c-------------------------------------------------------
fortran_source/geoclaw_bc2_fort.f:c-------------------------------------------------------
fortran_source/geoclaw_bc2_fort.f:c     # user-specified boundary conditions go here in place of error output
fortran_source/geoclaw_bc2_fort.f:c     # zero-order extrapolation:
fortran_source/geoclaw_bc2_fort.f:         do 415 i = 1-mbc, mx+mbc
fortran_source/geoclaw_bc2_fort.f:         do 435 i = 1-mbc, mx+mbc
fortran_source/geoclaw_bc2_fort.f:            aux(1,i,my+jbc) = aux(1,i,my+1-jbc)
fortran_source/geoclaw_bc2_fort.f:               q(m,i,my+jbc) = q(m,i,my+1-jbc)
fortran_source/geoclaw_bc2_fort.f:         do 436 i = 1-mbc, mx+mbc
fortran_source/geoclaw_bc2_fort.f:            q(3,i,my+jbc) = -q(3,i,my+1-jbc)
fortran_source/geoclaw_block_fort.f:      blockno_com = -1
fortran_source/geoclaw_qinit_fort.f90:    real(kind=8), intent(inout) :: q(meqn,1-mbc:mx+mbc,1-mbc:my+mbc)
fortran_source/geoclaw_qinit_fort.f90:    real(kind=8), intent(inout) :: aux(maux,1-mbc:mx+mbc,1-mbc:my+mbc)
fortran_source/geoclaw_qinit_fort.f90:    FORALL(i=1-mbc:mx+mbc, j=1-mbc:my+mbc)
fortran_source/geoclaw_qinit_fort.f90:        q(1,i,j) = max(0.d0, sea_level - aux(1,i,j))
geolib_source/qinit_module.f90:            write(GEO_PARM_UNIT,*) '--------------------------------------------'
geolib_source/qinit_module.f90:            write(GEO_PARM_UNIT,*) '-------------'
geolib_source/qinit_module.f90:        real(kind=8), intent(inout) :: q(meqn,1-mbc:mx+mbc,1-mbc:my+mbc)
geolib_source/qinit_module.f90:        real(kind=8), intent(inout) :: aux(maux,1-mbc:mx+mbc,1-mbc:my+mbc)
geolib_source/qinit_module.f90:            do i=1-mbc,mx+mbc
geolib_source/qinit_module.f90:                x = xlow_patch + (i-0.5d0)*dx
geolib_source/qinit_module.f90:                xim = x - 0.5d0*dx
geolib_source/qinit_module.f90:                do j=1-mbc,my+mbc
geolib_source/qinit_module.f90:                    y = ylow_patch + (j-0.5d0)*dy
geolib_source/qinit_module.f90:                    yjm = y - 0.5d0*dy
geolib_source/qinit_module.f90:                            dq = dq / ((xipc-ximc)*(yjpc-yjmc)*aux(mcapa,i,j))
geolib_source/qinit_module.f90:                            dq = dq / ((xipc-ximc)*(yjpc-yjmc))
geolib_source/qinit_module.f90:                            q(1,i,j) = max(dq-aux(1,i,j),0.d0)
geolib_source/qinit_module.f90:    ! surface elevation eta. The depth is then set as q(i,j,1)=max(eta-b,0)
geolib_source/qinit_module.f90:        mx_qinit = mx_qinit - 1
geolib_source/qinit_module.f90:        dx_qinit = (x_hi_qinit - x_low_qinit) / (mx_qinit-1)
geolib_source/qinit_module.f90:        dy_qinit = (y_hi_qinit - y_low_qinit) / (my_qinit-1)
geolib_source/qinit_module.f90:            etain_x(i) = xllower + etain_dx*(i-1)
geolib_source/qinit_module.f90:            etain_y(j) = yllower + etain_dy*(etain_my-j+1)
geolib_source/surge/storm_module.f90:!  Storm Surge Module - Contains generic routines for dealing with storm surge
geolib_source/surge/storm_module.f90:            real(kind=8), intent(inout) :: aux(maux,1-mbc:mx+mbc,1-mbc:my+mbc)
geolib_source/surge/storm_module.f90:            real(kind=8), intent(inout) :: aux(maux,1-mbc:mx+mbc,1-mbc:my+mbc)
geolib_source/surge/storm_module.f90:                R_refine(1) = -huge(1.d0)
geolib_source/surge/storm_module.f90:            if (-1 <= storm_specification_type .and.                    &
geolib_source/surge/storm_module.f90:    !  Powell Wind Drag - Sector based wind drag coefficients due to primary
geolib_source/surge/storm_module.f90:        drag = garret_wind_drag_limit(wind_speed, 3.5d-3)
geolib_source/surge/storm_module.f90:            weight(3) = 1.d0 - theta / 40.d0
geolib_source/surge/storm_module.f90:            weight(1) = 1.d0 - (theta - 130.d0) / 40.d0
geolib_source/surge/storm_module.f90:            weight(2) = (theta - 130.d0) / 40.d0
geolib_source/surge/storm_module.f90:            weight(2) = 1.d0 - (theta - 220.d0) / 40.d0
geolib_source/surge/storm_module.f90:            weight(3) = (theta - 220.d0) / 40.d0
geolib_source/surge/storm_module.f90:            drag(1) = min(2.d-3, drag(1))
geolib_source/surge/storm_module.f90:            drag(1) = 2.d-3 + 1.d-3 * (wind_speed - 35.d0) / 10.d0
geolib_source/surge/storm_module.f90:            drag(1) = 3.d-3
geolib_source/surge/storm_module.f90:            drag(2) = min(2.d-3, drag(2))
geolib_source/surge/storm_module.f90:            drag(2) = 2.d-3 - 1.d-3 * (wind_speed - 35.d0) / 10.d0
geolib_source/surge/storm_module.f90:            drag(2) = 1.d-3
geolib_source/surge/storm_module.f90:        if (drag(3) > 1.8d-3) then
geolib_source/surge/storm_module.f90:                drag(3) = 1.8d-3
geolib_source/surge/storm_module.f90:                drag(3) = 1.8d-3 + 2.7d-3 * (wind_speed - 25.d0) / 5.d0
geolib_source/surge/storm_module.f90:                drag(3) = 4.5d-3 - 3.5d-3 * (wind_speed - 30.d0) / 15.d0
geolib_source/surge/storm_module.f90:                drag(3) = 1.d-3
geolib_source/surge/storm_module.f90:        wind_drag = garret_wind_drag_limit(wind_speed, 2.d-3)
geolib_source/surge/storm_module.f90:                        1.d-3 * (0.75d0 + 0.067d0 * wind_speed))
geolib_source/surge/storm_module.f90:    !  No Wind Drag - Dummy function used to turn off wind drag forcing
geolib_source/surge/storm_module.f90:        real(kind=8), intent(in out) :: aux(maux,1-mbc:mx+mbc,1-mbc:my+mbc)
geolib_source/surge/model_storm_module.f90:        ! Landfall - This is not used explicitly (t0 = landfall ideally)
geolib_source/surge/model_storm_module.f90:        ! closed iso-bar of the storm
geolib_source/surge/model_storm_module.f90:    ! Storm field ramping width - Represents crudely the ramping radial area
geolib_source/surge/model_storm_module.f90:    ! Time tracking tolerance allowance - allows for the beginning of the storm
geolib_source/surge/model_storm_module.f90:    real(kind=8), parameter :: TRACKING_TOLERANCE = 1d-10
geolib_source/surge/model_storm_module.f90:            ! Now read in the storm data - note that the units are expected to 
geolib_source/surge/model_storm_module.f90:            do i=1,storm%num_casts - 1
geolib_source/surge/model_storm_module.f90:                dt = storm%track(1,i + 1) - storm%track(1,i)
geolib_source/surge/model_storm_module.f90:                    storm%velocity(1,i) = sign(ds / dt, y(1) - x(1))
geolib_source/surge/model_storm_module.f90:                    storm%velocity(2, i) = sign(ds / dt, y(2) - x(2))
geolib_source/surge/model_storm_module.f90:                    storm%velocity(1, i) = abs(x(2) - x(1)) / dt
geolib_source/surge/model_storm_module.f90:                    storm%velocity(2, i) = abs(y(2) - y(1)) / dt
geolib_source/surge/model_storm_module.f90:                                                            storm%num_casts - 1)
geolib_source/surge/model_storm_module.f90:            if (t0 <= storm%track(1, 1) - TRACKING_TOLERANCE) then
geolib_source/surge/model_storm_module.f90:            if (last_storm_index == -1) then
geolib_source/surge/model_storm_module.f90:            t0 = storm%track(1,last_storm_index - 1)
geolib_source/surge/model_storm_module.f90:            if ((abs(t0 - t) < TRACKING_TOLERANCE) .or.   &
geolib_source/surge/model_storm_module.f90:                (abs(t1 - t) < TRACKING_TOLERANCE) .or.   &
geolib_source/surge/model_storm_module.f90:                    index = -1
geolib_source/surge/model_storm_module.f90:                    do index=last_storm_index-1,2,-1
geolib_source/surge/model_storm_module.f90:                        if (storm%track(1,index-1) < t) exit
geolib_source/surge/model_storm_module.f90:            i = i - 1
geolib_source/surge/model_storm_module.f90:            ! the pre-calculated m/s velocities from before
geolib_source/surge/model_storm_module.f90:            x = x + (t - storm%track(1,i)) * storm%velocity(:,i)
geolib_source/surge/model_storm_module.f90:            tnm = storm%track(1,i-1)
geolib_source/surge/model_storm_module.f90:            weight = (t - tnm) / (tn - tnm)
geolib_source/surge/model_storm_module.f90:            fnm = [storm%track(2:3,i - 1),storm%velocity(:,i - 1), &
geolib_source/surge/model_storm_module.f90:                   storm%max_wind_radius(i - 1),storm%max_wind_speed(i - 1), &
geolib_source/surge/model_storm_module.f90:                   storm%central_pressure(i - 1), storm%radius(i - 1)]
geolib_source/surge/model_storm_module.f90:            fn = weight * (fn - fnm) + fnm
geolib_source/surge/model_storm_module.f90:        real(kind=8), intent(inout) :: aux(maux,1-mbc:mx+mbc,1-mbc:my+mbc)
geolib_source/surge/model_storm_module.f90:        mod_mws = mws - trans_speed
geolib_source/surge/model_storm_module.f90:        dp = Pa - Pc
geolib_source/surge/model_storm_module.f90:        do j=1-mbc,my+mbc
geolib_source/surge/model_storm_module.f90:            y = ylower + (j-0.5d0) * dy     ! Degrees latitude
geolib_source/surge/model_storm_module.f90:            do i=1-mbc,mx+mbc
geolib_source/surge/model_storm_module.f90:                x = xlower + (i-0.5d0) * dx   ! Degrees longitude
geolib_source/surge/model_storm_module.f90:                    ! lat-long coordinates, uses Haversine formula
geolib_source/surge/model_storm_module.f90:                    theta = atan2((y - sloc(2)) * DEG2RAD,(x - sloc(1)) * DEG2RAD)
geolib_source/surge/model_storm_module.f90:                    r = sqrt( (x - sloc(1))**2 + (y - sloc(2))**2)
geolib_source/surge/model_storm_module.f90:                    theta = atan2(y - sloc(2), x - sloc(1))
geolib_source/surge/model_storm_module.f90:                aux(pressure_index,i,j) = Pc + dp * exp(-(mwr / r)**B)
geolib_source/surge/model_storm_module.f90:                        * exp(1.d0 - (mwr / r)**B) * mws**2.d0 &
geolib_source/surge/model_storm_module.f90:                        + (r * f)**2.d0 / 4.d0) - r * f / 2.d0
geolib_source/surge/model_storm_module.f90:                aux(wind_index,i,j)   = -wind * sin(theta)
geolib_source/surge/model_storm_module.f90:                ramp = 0.5d0 * (1.d0 - tanh((r - radius) / RAMP_WIDTH))
geolib_source/surge/model_storm_module.f90:                aux(pressure_index,i,j) = Pa + (aux(pressure_index,i,j) - Pa) &
geolib_source/surge/model_storm_module.f90:        real(kind=8), intent(inout) :: aux(maux,1-mbc:mx+mbc,1-mbc:my+mbc)
geolib_source/surge/model_storm_module.f90:        real(kind=8), intent(inout) :: aux(maux,1-mbc:mx+mbc,1-mbc:my+mbc)
geolib_source/surge/data_storm_module.f90:        stop "Data-derived storm are not yet implemented!"
geolib_source/surge/data_storm_module.f90:        stop "Data-derived storm are not yet implemented!"
geolib_source/surge/data_storm_module.f90:        stop "Data-derived storm are not yet implemented!"
geolib_source/surge/data_storm_module.f90:        real(kind=8), intent(inout) :: aux(maux,1-mbc:mx+mbc,1-mbc:my+mbc)
geolib_source/movetopo.f:      implicit double precision (a-h,o-z)
geolib_source/movetopo.f:      dimension aux(maux,1-mbc:mx+mbc,1-mbc:my+mbc)
geolib_source/movetopo.f:      dimension auxorig(maux,-1:mx+mbc,-1:my+mbc)
geolib_source/movetopo.f:        dkk = (tt-t0dtopo)/dtdtopo
geolib_source/movetopo.f:        tdtopom = t0dtopo+dtdtopo*(kkm-1)
geolib_source/movetopo.f:        tau = 1.d0-max(0.d0,((tt-tdtopom)/dtdtopo))
geolib_source/movetopo.f:        do j=1-mbc,my+mbc
geolib_source/movetopo.f:            ycell = ylow + (j-0.5d0)*dy
geolib_source/movetopo.f:            yjm =   ylow + (j-1.d0)*dy
geolib_source/movetopo.f:              dyc=yjpc-yjmc
geolib_source/movetopo.f:           do i=1-mbc,mx+mbc
geolib_source/movetopo.f:              xcell =  xlow + (i- 0.5d0)*dx
geolib_source/movetopo.f:              xim =    xlow + (i- 1.0d0)*dx
geolib_source/movetopo.f:                 dxc=xipc-ximc
geolib_source/movetopo.f:                 aux(1,i,j)=aux(1,i,j)+tau*dauxijm+(1.d0-tau)*dauxijp
geolib_source/movetopo.f:     &      xlow+(0.5d0-mbc)*dx.lt.xlower) then
geolib_source/movetopo.f:            do j=1-mbc,my+mbc
geolib_source/movetopo.f:               ycell = ylow +(j-0.5d0)*dy
geolib_source/movetopo.f:               yjm = ylow  + (j-1.0d0)*dy
geolib_source/movetopo.f:               xcell =  xlow + (1- 0.5d0)*dx
geolib_source/movetopo.f:                   do i=1-mbc,0
geolib_source/movetopo.f:     &      xlow+(mx+mbc-0.5d0)*dx.gt.xupper) then
geolib_source/movetopo.f:            do j=1-mbc,my+mbc
geolib_source/movetopo.f:               ycell = ylow+(j-0.5d0)*dy
geolib_source/movetopo.f:               yjm = ylow+(j-1.0d0)*dy
geolib_source/movetopo.f:               xcell =  xlow + (mx-0.5d0)*dx
geolib_source/movetopo.f:               xim =  xlow + (mx-1.d0)*dx
geolib_source/movetopo.f:     &             ylow+(.5d0-mbc)*dy.lt.ylower) then
geolib_source/movetopo.f:                  do i=1-mbc,mx+mbc
geolib_source/movetopo.f:               ycell = ylow+(1-0.5d0)*dy
geolib_source/movetopo.f:               xcell =  xlow + (i- 0.5d0)*dx
geolib_source/movetopo.f:               xim =  xlow + (i- 1.d0)*dx
geolib_source/movetopo.f:                   do j=1-mbc,0
geolib_source/movetopo.f:     &             ylow+(my+mbc-0.5d0)*dy.gt.yupper) then
geolib_source/movetopo.f:            do i=1-mbc,mx+mbc
geolib_source/movetopo.f:               ycell = ylow+(my-0.5d0)*dy
geolib_source/movetopo.f:               yjm = ylow+(my-1.d0)*dy
geolib_source/movetopo.f:               xcell =  xlow + (i- 0.5d0)*dx
geolib_source/movetopo.f:               xim =   xlow + (i- 1.d0)*dx
geolib_source/movetopo.f:        if (tt-dt.gt.tfdtopo) then
geolib_source/movetopo.f:              xcell=xlowtopo(m) + (ib-.5d0)*dxtopo(m)
geolib_source/movetopo.f:              xim=xlowtopo(m) + (ib-1.d0)*dxtopo(m)
geolib_source/movetopo.f:                dxc=xipc-ximc
geolib_source/movetopo.f:                     ycell=ylowtopo(m) + (jb-.5d0)*dytopo(m)
geolib_source/movetopo.f:                     yjm=ylowtopo(m) + (jb-1.d0)*dytopo(m)
geolib_source/movetopo.f:                if (yjm.lt.yhidtopo.and.yjp.gt.ylowdtopo) then !orig changed to match 4-x
geolib_source/movetopo.f:                    dyc = yjpc-yjmc
geolib_source/movetopo.f:     &               (sin(yjp*deg2rad)-sin(yjm*deg2rad))/dyc
geolib_source/movetopo.f:                   jbr = mytopo(m)-jb+1
geolib_source/movetopo.f:                   ij = i0topo(m) + (jbr-1)*mxtopo(m) +ib -1
geolib_source/src1d.f90:! which applies source terms for a 1-d slice of data along the
geolib_source/src1d.f90:! fix-up is applied and is used to apply source terms over partial
geolib_source/src1d.f90:    real(kind=8), parameter :: depth_tolerance = 1.0d-30
geolib_source/src1d.f90:            ! If depth is near-zero, set momentum to zero
geolib_source/src1d.f90:                    do nman = num_manning, 1, -1
geolib_source/src1d.f90:    ! Only lat-long coordinate system supported here right now
geolib_source/src1d.f90:            a(1,1) = 1.d0 - 0.5d0 * fdt**2 + fdt**4 / 24.d0
geolib_source/src1d.f90:            a(1,2) =  fdt - fdt**3 / 6.d0
geolib_source/src1d.f90:            a(2,1) = -fdt + fdt**3 / 6.d0
geolib_source/topointegral.f:      implicit double precision (a-h,o-z)
geolib_source/topointegral.f:      xxhi=xxlow+(mxx-1)*dxx
geolib_source/topointegral.f:      yyhi=yylow+(myy-1)*dyy
geolib_source/topointegral.f:      if ((xim-xxlow).lt.0.d0.or.(xip-xxhi).gt.0.d0) then
geolib_source/topointegral.f:      if ((yjm-yylow).lt.0.d0.or.(yjp-yyhi).gt.0.d0) then
geolib_source/topointegral.f:      dx=xip-xim
geolib_source/topointegral.f:      dy=yjp-yjm
geolib_source/topointegral.f:         djjstart=(yjm-yylow)/dyy
geolib_source/topointegral.f:         diistart=(xim-xxlow)/dxx
geolib_source/topointegral.f:         diiend=(xip-xxlow)/dxx
geolib_source/topointegral.f:         djjend=(yjp-yylow)/dyy
geolib_source/topointegral.f:         do jj=jjstart,jjend-1
geolib_source/topointegral.f:            y1=yylow + (jj-1.d0)*dyy
geolib_source/topointegral.f:            jjz1= myy-jj+1
geolib_source/topointegral.f:            jjz2= jjz1-1
geolib_source/topointegral.f:            do ii=iistart,iiend-1
geolib_source/topointegral.f:               x1=xxlow + (ii-1.d0)*dxx
geolib_source/fixedgrids_module.f90:            write(parmunit,*) '--------------------------------------------'
geolib_source/fixedgrids_module.f90:            write(parmunit,*) '-----------'
geolib_source/fixedgrids_module.f90:                       fgrids(i)%dt = (fgrids(i)%end_time - fgrids(i)%start_time) &
geolib_source/fixedgrids_module.f90:                                           / (fgrids(i)%num_output - 1)
geolib_source/fixedgrids_module.f90:                fgrids(i)%last_output_time = fgrids(i)%start_time - fgrids(i)%dt
geolib_source/fixedgrids_module.f90:                   fgrids(i)%dx = (fgrids(i)%x_hi - fgrids(i)%x_low) / (fgrids(i)%mx - 1)
geolib_source/fixedgrids_module.f90:                    fgrids(i)%dy = (fgrids(i)%y_hi - fgrids(i)%y_low) / (fgrids(i)%my - 1)
geolib_source/fixedgrids_module.f90:           tcfmax=-1.d16
geolib_source/fixedgrids_module.f90:        real(kind=8), intent(in) :: q(meqn,1-mbc:mxc+mbc,1-mbc:myc+mbc)
geolib_source/fixedgrids_module.f90:        real(kind=8), intent(in) :: aux(maux,1-mbc:mxc+mbc,1-mbc:myc+mbc)
geolib_source/fixedgrids_module.f90:        real(kind=8), parameter :: arrival_tolerance = 1.d-2
geolib_source/fixedgrids_module.f90:            xfg=fgrid%x_low + (ifg-1)*fgrid%dx
geolib_source/fixedgrids_module.f90:                yfg=fgrid%y_low + (jfg-1)*fgrid%dy
geolib_source/fixedgrids_module.f90:                    ic1 = int((xfg-(xlowc+0.5d0*dxc))/(dxc))+1
geolib_source/fixedgrids_module.f90:                    jc1 = int((yfg-(ylowc+0.5d0*dyc))/(dyc))+1
geolib_source/fixedgrids_module.f90:                    if (ic1.eq.mxc) ic1=mxc-1
geolib_source/fixedgrids_module.f90:                    if (jc1.eq.myc) jc1=myc-1 
geolib_source/fixedgrids_module.f90:                    xc1 = xlowc + dxc * (ic1 - 0.5d0)
geolib_source/fixedgrids_module.f90:                    yc1 = ylowc + dyc * (jc1 - 0.5d0)
geolib_source/fixedgrids_module.f90:                    xc2 = xlowc + dxc * (ic2 - 0.5d0)
geolib_source/fixedgrids_module.f90:                    yc2 = ylowc + dyc * (jc2 - 0.5d0)
geolib_source/fixedgrids_module.f90:                    geometry = [(xfg - xc1) / dxc, &
geolib_source/fixedgrids_module.f90:                                (yfg - yc1) / dyc, &
geolib_source/fixedgrids_module.f90:                                (xfg - xc1) * (yfg - yc1) / (dxc*dyc), &
geolib_source/fixedgrids_module.f90:                        ! wet, if not re-balance
geolib_source/fixedgrids_module.f90:            enddo ! Fixed grid y-coordinate loop
geolib_source/fixedgrids_module.f90:        enddo ! Fixed grid x-coordinte loop
geolib_source/fixedgrids_module.f90:        do pos = 9, 8, -1
geolib_source/fixedgrids_module.f90:        do pos = 14, 11, -1
geolib_source/fixedgrids_module.f90:        columns = fgrid%num_vars(1) - 1
geolib_source/fixedgrids_module.f90:                tau = (out_time - t0) / (tf - t0)
geolib_source/fixedgrids_module.f90:                forall(m=1:fgrid%num_vars(1)-1,abs(fgrid%early(m,i,j)) < 1d-90)
geolib_source/fixedgrids_module.f90:                forall(m=1:fgrid%num_vars(1)-1,abs(fgrid%late(m,i,j)) < 1d-90)
geolib_source/fixedgrids_module.f90:                if (columns == fgrid%num_vars(1) - 1) then 
geolib_source/fixedgrids_module.f90:                    if (abs(fgrid%often(eta_min_index,i,j)) < 1d-90) then
geolib_source/fixedgrids_module.f90:                    if (abs(fgrid%often(eta_max_index,i,j)) < 1d-90) then
geolib_source/fixedgrids_module.f90:            do pos = 9, 8, -1
geolib_source/fixedgrids_module.f90:        interpolant = sum([points(2,1)-points(1,1), &
geolib_source/fixedgrids_module.f90:                           points(1,2)-points(1,1), &
geolib_source/fixedgrids_module.f90:                           points(1,1) + points(2,2) - (points(2,1) + points(1,2)), &
geolib_source/fixedgrids_module.f90:        interpolant = (1.d0 - tau) * early(:) + tau * late(:)
geolib_source/bilinearintegral.f:      area = (yhi-ylow)*(xhi-xlow)
geolib_source/bilinearintegral.f:      sumxi = (xhi + xlow - 2.d0*x1)/dxx
geolib_source/bilinearintegral.f:      sumeta = (yhi + ylow - 2.d0*y1)/dyy
geolib_source/bilinearintegral.f:      a = z21-z11
geolib_source/bilinearintegral.f:      b = z12-z11
geolib_source/bilinearintegral.f:      c = z22-z21-z12+z11
geolib_source/bilinearintegral.f:      delx = xhi - xlo
geolib_source/bilinearintegral.f:      dely = yhi - ylo
geolib_source/bilinearintegral.f:      xdiffhi = xhi - x1
geolib_source/bilinearintegral.f:      xdifflo = xlo - x1
geolib_source/bilinearintegral.f:      ydiffhi = yhi - y1
geolib_source/bilinearintegral.f:      ydifflo = ylo - y1
geolib_source/bilinearintegral.f:      xdiff2 = 0.5d0*(xdiffhi**2 - xdifflo**2)
geolib_source/bilinearintegral.f:     &            -(r2d*cos(d2r*ylo) + ydifflo*sin(d2r*ylo))
geolib_source/bilinearintegral.f:      adsinint = r2d*(sin(d2r*yhi) - sin(d2r*ylo))
geolib_source/bilinearintegral.f:      a = (z21-z11)/dxx
geolib_source/bilinearintegral.f:      b = (z12-z11)/dyy
geolib_source/bilinearintegral.f:      c = (z22-z21-z12+z11)/(dxx*dyy)
geolib_source/allowflag.f:      implicit double precision (a-h,o-z)
geolib_source/cellgridintegrate.f:      implicit double precision (a-h,o-z)
geolib_source/cellgridintegrate.f:         cellarea = (xip-xim)*(yjp-yjm)
geolib_source/cellgridintegrate.f:      do m = mtopofiles,1,-1
geolib_source/cellgridintegrate.f:            do mm = m-1,1,-1
geolib_source/cellgridintegrate.f:                  topoint = topoint - topointegral(
geolib_source/cellgridintegrate.f:c                  -----------------------------------------------------
geolib_source/cellgridintegrate.f:c                 ------------------------------------------------------------
geolib_source/cellgridintegrate.f:                  do mmm = mm-1,1,-1
geolib_source/cellgridintegrate.f:                        do m4 = mmm-1,1,-1
geolib_source/cellgridintegrate.f:                              topoint = topoint - topointegral(
geolib_source/cellgridintegrate.f:                                 do m5 = m4-1,1,-1
geolib_source/cellgridintegrate.f:c           ------------------------------------------------------------
geolib_source/cellgridintegrate.f:         area = (xinthi-xintlo)*(yinthi-yintlo)
geolib_source/cellgridintegrate2.f:c *** Note: xcell and ycell are no longer needed -- should be removed.
geolib_source/cellgridintegrate2.f:      implicit double precision (a-h,o-z)
geolib_source/cellgridintegrate2.f:         cellarea = (xip-xim)*(yjp-yjm)
geolib_source/refinement_module.f90:    !  Flowgrades - Not updated yet, use at your own risk
geolib_source/refinement_module.f90:            write(GEO_PARM_UNIT,*) '--------------------------------------------'
geolib_source/refinement_module.f90:            write(GEO_PARM_UNIT,*) '------------------------------'
geolib_source/refinement_module.f90:        write(GEO_PARM_UNIT,*) '--------------------------------------------'
geolib_source/refinement_module.f90:        write(GEO_PARM_UNIT,*) '------------'
geolib_source/utility_module.f90:        search_buffer = trim(line(1:index(line,"=:") - 2))
geolib_source/utility_module.f90:        word(nw) = trim(adjustl(str2(1:pos2-1)))
geolib_source/utility_module.f90:    !------------------------------------------------------------------------------
geolib_source/utility_module.f90:    !       Fortran-95
geolib_source/utility_module.f90:    !       1995 Springer-Verlag, New York.
geolib_source/utility_module.f90:    !       Written by:     Paul van Delst, CIMSS/SSEC 18-Oct-1999
geolib_source/utility_module.f90:    !S-
geolib_source/utility_module.f90:    !------------------------------------------------------------------------------
geolib_source/utility_module.f90:    !   Based on code originally by Paul van Delst, CIMSS/SSEC 18-Oct-1999
geolib_source/utility_module.f90:    !       1995 Springer-Verlag, New York.
geolib_source/utility_module.f90:        ! -- copy input string
geolib_source/utility_module.f90:        ! -- loop over string elements
geolib_source/utility_module.f90:            ! -- find location of letter in lower case constant string
geolib_source/utility_module.f90:            ! -- if current substring is a lower case letter, make it upper case
geolib_source/utility_module.f90:    !       Paul van Delst, CIMSS/SSEC 18-Oct-1999
geolib_source/utility_module.f90:    !       1995 Springer-Verlag, New York.
geolib_source/topo_module.f90:            write(GEO_PARM_UNIT,*) '--------------------------------------------'
geolib_source/topo_module.f90:            write(GEO_PARM_UNIT,*) '---------'
geolib_source/topo_module.f90:                write(GEO_PARM_UNIT,*) '   mtopofiles = ',mtopofiles-num_dtopo
geolib_source/topo_module.f90:                do i=1,mtopofiles - num_dtopo
geolib_source/topo_module.f90:                do i= mtopofiles - num_dtopo + 1, mtopofiles
geolib_source/topo_module.f90:                   j = i - mtopofiles + num_dtopo
geolib_source/topo_module.f90:                   topotime(i) = -huge(1.0)
geolib_source/topo_module.f90:                        i0topo(i)=i0topo(i-1) + mtopo(i-1)
geolib_source/topo_module.f90:                do i=1,mtopofiles - num_dtopo
geolib_source/topo_module.f90:                    topotime(i) = -huge(1.0)
geolib_source/topo_module.f90:                        xlowtopo(i),ylowtopo(i),topowork(i0topo(i):i0topo(i)+mtopo(i)-1))
geolib_source/topo_module.f90:                    do j=mtopofiles - num_dtopo + 1, mtopofiles
geolib_source/topo_module.f90:                    rank = mtopofiles - finer_than
geolib_source/topo_module.f90:                do i = mtopofiles - num_dtopo + 1, mtopofiles
geolib_source/topo_module.f90:                        xlowtopo(i),yhitopo(i), topowork(i0topo(i):i0topo(i)+mtopo(i)-1))
geolib_source/topo_module.f90:                      i0topo0(i)= i0topo0(i-1) + mtopo(i-1)*topo0save(i-1)
geolib_source/topo_module.f90:                         topo0work(i0topo0(i):i0topo0(i)+mtopo(i)-1) = &
geolib_source/topo_module.f90:                            topowork(i0topo(i):i0topo(i)+mtopo(i)-1)
geolib_source/topo_module.f90:                area_domain = (yupper-ylower)*(xupper-xlower)
geolib_source/topo_module.f90:                if (abs(area - area_domain) > 1e-2*area_domain) then
geolib_source/topo_module.f90:                else if (abs(area - area_domain) > 1e-12*area_domain) then
geolib_source/topo_module.f90:            !---------------tests for analytic bathymetry-------------------
geolib_source/topo_module.f90:                topo_shelf_slope = (topo_basin_depth - topo_shelf_depth) &
geolib_source/topo_module.f90:                                            / (topo_x0 - topo_x1)
geolib_source/topo_module.f90:               y = yhi - (j-1)*dy
geolib_source/topo_module.f90:               x = xlow + (i-1)*dx
geolib_source/topo_module.f90:               ij = (j-1)*mx + i
geolib_source/topo_module.f90:                  if (id.gt.mtopofiles-num_dtopo) then
geolib_source/topo_module.f90:                     itopo1 = int(floor((x-xlowtopo(id))/dxtopo(id)))+1
geolib_source/topo_module.f90:                     itopo2 = int(ceiling((x-xlowtopo(id))/dxtopo(id)))+1
geolib_source/topo_module.f90:                     jtopo1 = int(floor((yhitopo(id)-y)/dytopo(id))) + 1
geolib_source/topo_module.f90:                     jtopo2 = int(ceiling((yhitopo(id)-y)/dytopo(id))) + 1
geolib_source/topo_module.f90:                     ijll = i0topo(id) + (jtopo2-1)*mxtopo(id) + itopo1 -1
geolib_source/topo_module.f90:                     ijlr = i0topo(id) + (jtopo2-1)*mxtopo(id) + itopo2 -1
geolib_source/topo_module.f90:                     ijul = i0topo(id) + (jtopo1-1)*mxtopo(id) + itopo1 -1
geolib_source/topo_module.f90:                     ijur = i0topo(id) + (jtopo1-1)*mxtopo(id) + itopo2 -1
geolib_source/topo_module.f90:                     xl = xlowtopo(id) + real(itopo1-1,kind=8)*dxtopo(id)
geolib_source/topo_module.f90:                     yu = yhitopo(id) - real(jtopo1-1,kind=8)*dytopo(id)
geolib_source/topo_module.f90:                     yl = yu - dytopo(id)
geolib_source/topo_module.f90:                     z = zll*(xr-x)*(yu-y) + zlr*(x-xl)*(yu-y) + zul*(xr-x)*(y-yl) + zur*(x-xl)*(y-yl)
geolib_source/topo_module.f90:                            read(iunit,*) (topo((j-1)*mx + i),i=1,mx)
geolib_source/topo_module.f90:                                if (topo((j-1)*mx + i) == no_data_value) then
geolib_source/topo_module.f90:                                    topo((j-1)*mx + i) = topo_missing
geolib_source/topo_module.f90:                z_var_id = -1
geolib_source/topo_module.f90:                if (z_var_id == -1) then
geolib_source/topo_module.f90:                        do j = 0, my - 1
geolib_source/topo_module.f90:                            topo(j * mx + 1:(j + 1) * mx) = nc_buffer(:, my - j)
geolib_source/topo_module.f90:                        do j = 0, my - 1
geolib_source/topo_module.f90:                            topo(j * mx + 1:(j + 1) * mx) = nc_buffer(my - j, :)
geolib_source/topo_module.f90:                    !     i = i - 1
geolib_source/topo_module.f90:                    !     topo((i - 1) * mx + 1:)
geolib_source/topo_module.f90:                    !     row_index = row_index - 1
geolib_source/topo_module.f90:                    !     print *, (row_index-1)*mx + 1, (row_index-1)*mx + mx
geolib_source/topo_module.f90:                    !     !       topo((row_index-1)*mx + 1:(row_index-1)*mx + mx),  &
geolib_source/topo_module.f90:                    !     topo((row_index - 1) * mx + 1:(row_index - 1) * mx + mx) = &
geolib_source/topo_module.f90:                                topo = -topo
geolib_source/topo_module.f90:                topo(i) = -topo(i)
geolib_source/topo_module.f90:!             write(29,*) -9999, '     nodataval'
geolib_source/topo_module.f90:    !   - fname - (char) Name of file
geolib_source/topo_module.f90:    !   - topo_type - (int) Type of topography file (-3 < topo_type < 3)
geolib_source/topo_module.f90:    !   - mx,my - (int) Number of grid points
geolib_source/topo_module.f90:    !   - xll,yll,xhi,yhi - (float) Lower and upper coordinates for grid
geolib_source/topo_module.f90:    !   - dx,dy - (float) Spatial resolution of grid
geolib_source/topo_module.f90:                mx = mx - 1
geolib_source/topo_module.f90:                dx = (xhi-xll) / (mx-1)
geolib_source/topo_module.f90:                dy = (yhi-yll) / (my-1)
geolib_source/topo_module.f90:                xhi = xll + (mx-1)*dx
geolib_source/topo_module.f90:                yhi = yll + (my-1)*dy
geolib_source/topo_module.f90:                ! if (ios /= NF90_NOERR .or. convention_string(1:3) /= "CF-") then
geolib_source/topo_module.f90:                !     print *, "conventions and meta-data.  Please see the"
geolib_source/topo_module.f90:                dx = xlocs(2) - xlocs(1)
geolib_source/topo_module.f90:                dy = ylocs(2) - ylocs(1)
geolib_source/topo_module.f90:                x_in_dom = (xlocs.gt.(xlower-dx)) .and. (xlocs.lt.(xupper+dx))
geolib_source/topo_module.f90:                y_in_dom = (ylocs.gt.(ylower-dy)) .and. (ylocs.lt.(yupper+dy))
geolib_source/topo_module.f90:                topography = topo_shelf_slope * (x-topo_x0) + topo_basin_depth
geolib_source/topo_module.f90:                topography = topo_beach_slope * (x-topo_x2) + topo_shelf_depth
geolib_source/topo_module.f90:    ! Time-dependend topography is used to initiate tsunami, for example.
geolib_source/topo_module.f90:        write(GEO_PARM_UNIT,*) '--------------------------------------------'
geolib_source/topo_module.f90:        write(GEO_PARM_UNIT,*) '-------------'
geolib_source/topo_module.f90:                i0dtopo(i) = i0dtopo(i-1) + mdtopo(i-1)
geolib_source/topo_module.f90:                rank = num_dtopo - finer_than
geolib_source/topo_module.f90:                dtopofname(i),dtopowork(i0dtopo(i):i0dtopo(i)+mdtopo(i)-1))
geolib_source/topo_module.f90:                  read(iunit,*) (dtopo((k-1)*mx*my + (j-1)*mx + i) , i=1,mx)
geolib_source/topo_module.f90:    !   - fname - (char) Name of the dtopo file
geolib_source/topo_module.f90:    !   - topo_type - (int) Topography file type (1-3 are valid)
geolib_source/topo_module.f90:    !   - mx,my,mt - (int) Number of grid point in space (mx,my) and time (mt)
geolib_source/topo_module.f90:    !   - xlow,ylow - (dp) Lower corner spatial coordinate of grid
geolib_source/topo_module.f90:    !   - xhi,yhi - (dp) Upper corner spatial coodinate of grid
geolib_source/topo_module.f90:    !   - t0,tf - (dp) Beginning and end times for the file
geolib_source/topo_module.f90:    !   - dx,dy,dt - (dp) Distance between space (dx,dy) and time (dt) points
geolib_source/topo_module.f90:                mx = (topo_size-1)/my
geolib_source/topo_module.f90:                mt = (topo_size-1)/ (my*mx)
geolib_source/topo_module.f90:                dx = (xhi-xlow) / (mx-1)
geolib_source/topo_module.f90:                dy = (yhi-ylow) / (my-1)
geolib_source/topo_module.f90:                dt = (tf - t0) / (mt-1)
geolib_source/topo_module.f90:                xhi = xlow + dx*(mx-1)
geolib_source/topo_module.f90:                yhi = ylow + dy*(my-1)
geolib_source/topo_module.f90:                tf = t0 + dt*(mt-1)
geolib_source/topo_module.f90:         ! only using coarsest topo grid -- compute directly...
geolib_source/topo_module.f90:            area = area1 - area2 + area_m
geolib_source/topo_module.f90:         ! only using coarsest topo grid -- compute directly...
geolib_source/topo_module.f90:            integral = int1 - int2 + int3
geolib_source/topo_module.f90:         area = (xinthi-xintlo)*(yinthi-yintlo)
geolib_source/topo_module.f90:    INTEGER,PARAMETER  :: DUC = ICHAR('A') - ICHAR('a')
geolib_source/qad.f:c -------------------------------------------------------------
geolib_source/qad.f:       implicit double precision (a-h, o-z)
geolib_source/qad.f:       iaddaux(iaux,i) = iaux + maux*(i-1)
geolib_source/qad.f:c  ---------------------------------------------------------------
geolib_source/qad.f:c      # for GeoClaw we skip this routine --- need to fix someday:
geolib_source/qad.f:c  ---------------------------------------------------------------
geolib_source/qad.f:       nc = mjtot-2*nghost
geolib_source/qad.f:       nr = mitot-2*nghost
geolib_source/qad.f:c--------
geolib_source/qad.f:c--------
geolib_source/qad.f:       do 10 j = nghost+1, mjtot-nghost
geolib_source/qad.f:c                # Assuming velocity at left-face, this fix
geolib_source/qad.f:                 auxl(iaddaux(ma,j-nghost+1)) = aux(ma,nghost+1,j)
geolib_source/qad.f:c                # Normal case -- we set the aux arrays 
geolib_source/qad.f:                 auxl(iaddaux(ma,j-nghost+1)) = aux(ma,nghost,j)
geolib_source/qad.f:         ql(ivar,j-nghost+1) = valbig(ivar,nghost,j)
geolib_source/qad.f:       ncrse = (mjtot-2*nghost)/lratioy
geolib_source/qad.f:            write(dbugunit,4101) i,qr(1,i-1),ql(1,i)
geolib_source/qad.f:                write(dbugunit,4101) i,(auxr(iaddaux(ma,i-1)),ma=1,maux)
geolib_source/qad.f:       call rpn2(1,max1dp1-2*nghost,nvar,mwaves,maux,nghost,
geolib_source/qad.f:     .           nc+1-2*nghost,ql,qr,auxl,auxr,wave,s,amdq,apdq)
geolib_source/qad.f:          jfine = (j-1)*lratioy
geolib_source/qad.f:c--------
geolib_source/qad.f:c--------
geolib_source/qad.f:       do 210 i = nghost+1, mitot-nghost
geolib_source/qad.f:             auxr(iaddaux(ma,i-nghost)) = aux(ma,i,mjtot-nghost+1)
geolib_source/qad.f:            qr(ivar,i-nghost) = valbig(ivar,i,mjtot-nghost+1)
geolib_source/qad.f:       ncrse = (mitot-2*nghost)/lratiox
geolib_source/qad.f:c                # Assuming velocity at bottom-face, this fix
geolib_source/qad.f:                 ifine = (ic-1)*lratiox + nghost + l
geolib_source/qad.f:                 auxl(iaddaux(ma,lind+1)) = aux(ma,ifine,mjtot-nghost+1)
geolib_source/qad.f:       call rpn2(2,max1dp1-2*nghost,nvar,mwaves,maux,nghost,
geolib_source/qad.f:     .              nr+1-2*nghost,ql,qr,auxl,auxr,wave,s,amdq,apdq)
geolib_source/qad.f:          ifine = (i-1)*lratiox
geolib_source/qad.f:     .                     - amdq(ivar,ifine+l+1) * hx * delt
geolib_source/qad.f:     .                     - apdq(ivar,ifine+l+1) * hx * delt
geolib_source/qad.f:c--------
geolib_source/qad.f:c--------
geolib_source/qad.f:       do 310 j = nghost+1, mjtot-nghost
geolib_source/qad.f:             auxr(iaddaux(ma,j-nghost)) = aux(ma,mitot-nghost+1,j)
geolib_source/qad.f:          qr(ivar,j-nghost) = valbig(ivar,mitot-nghost+1,j)
geolib_source/qad.f:       ncrse = (mjtot-2*nghost)/lratioy
geolib_source/qad.f:c                # Assuming velocity at left-face, this fix
geolib_source/qad.f:                 jfine = (jc-1)*lratioy + nghost + l
geolib_source/qad.f:                 auxl(iaddaux(ma,lind+1)) = aux(ma,mitot-nghost+1,jfine)
geolib_source/qad.f:       call rpn2(1,max1dp1-2*nghost,nvar,mwaves,maux,nghost,
geolib_source/qad.f:     .              nc+1-2*nghost,ql,qr,auxl,auxr,wave,s,amdq,apdq)
geolib_source/qad.f:          jfine = (j-1)*lratioy
geolib_source/qad.f:     .                     - amdq(ivar,jfine+l+1) * hy * delt
geolib_source/qad.f:     .                     - apdq(ivar,jfine+l+1) * hy * delt
geolib_source/qad.f:c--------
geolib_source/qad.f:c--------
geolib_source/qad.f:       do 410 i = nghost+1, mitot-nghost
geolib_source/qad.f:c                # Assuming velocity at bottom-face, this fix
geolib_source/qad.f:                 auxl(iaddaux(ma,i-nghost+1)) = aux(ma,i,nghost+1)
geolib_source/qad.f:                 auxl(iaddaux(ma,i-nghost+1)) = aux(ma,i,nghost)
geolib_source/qad.f:          ql(ivar,i-nghost+1) = valbig(ivar,i,nghost)
geolib_source/qad.f:       ncrse = (mitot-2*nghost)/lratiox
geolib_source/qad.f:       call rpn2(2,max1dp1-2*nghost,nvar,mwaves,maux,nghost,
geolib_source/qad.f:     .              nr+1-2*nghost,ql,qr,auxl,auxr,wave,s,amdq,apdq)
geolib_source/qad.f:          ifine = (i-1)*lratiox
geolib_source/qad.f:c      # This is commented out for now --- updating the momenumtum due
geolib_source/qad.f:c      # the f-wave formulation?
geolib_source/geoclaw_module.f90:!    Copyright (C) 2010-04-21 Clawpack Developers http://www.clawpack.org
geolib_source/geoclaw_module.f90:    real(kind=8) :: theta_0 ! Used if using the beta-plane approximation
geolib_source/geoclaw_module.f90:            write(GEO_PARM_UNIT,*) '--------------------------------------------'
geolib_source/geoclaw_module.f90:            write(GEO_PARM_UNIT,*) '-------------------'
geolib_source/geoclaw_module.f90:                read(unit,*) manning_break(1:num_manning-1)
geolib_source/geoclaw_module.f90:            ! coordinate_system = 2 means lat-long grid on sphere
geolib_source/geoclaw_module.f90:    !       A beta-plane approximation is used and y should be in meters
geolib_source/geoclaw_module.f90:    !       Grid is in lat-long and y should be in degrees which is converted
geolib_source/geoclaw_module.f90:            coriolis = 2.d0 * omega * (sin(theta_0) + (theta - theta_0)     &
geolib_source/geoclaw_module.f90:        dx = (x2 - x1) * DEG2RAD
geolib_source/geoclaw_module.f90:        dy = (y2 - y1) * DEG2RAD
geolib_source/geoclaw_module.f90:    ! Transform long,lat --> (x,y) coordinates.
geolib_source/geoclaw_module.f90:    !    projection_center(2) = (longitude (E/W),latitude (N/S)) - coordinates 
geolib_source/geoclaw_module.f90:        x(1) = deg2rad * earth_radius * (coords(1) - &
geolib_source/geoclaw_module.f90:    ! Transform (x,y) --> (lat,lon) coordinates.
geolib_source/geoclaw_module.f90:    !    projection_center(2) = (longitude (E/W),latitude (N/S)) - coordinates 
geolib_source/readqinit.f:      implicit double precision (a-h,o-z)
geolib_source/readqinit.f:c     # surface elevation eta. The depth is then set as q(i,j,1)=max(eta-b,0)
geolib_source/readqinit.f:      dx=(xf-x0)/(mx-1)
geolib_source/readqinit.f:      dy=-(yf-y0)/(my-1)
geolib_source/readqinit.f:c       values are now noded based, no longer considered cell-centered
geolib_source/readqinit.f:c      xlow = x0-.5d0*dx
geolib_source/readqinit.f:c      ylow = yf-.5d0*dy
geolib_source/friction_module.f90:    !  set_friction_field - 
geolib_source/friction_module.f90:                                            1-num_ghost:mx+num_ghost,&
geolib_source/friction_module.f90:                                            1-num_ghost:my+num_ghost)
geolib_source/friction_module.f90:                do i=1 - num_ghost, mx + num_ghost
geolib_source/friction_module.f90:                    do j=1 - num_ghost, my + num_ghost    
geolib_source/friction_module.f90:                        x = xlower + (i-0.5d0) * dx
geolib_source/friction_module.f90:                        y = ylower + (j-0.5d0) * dy
geolib_source/friction_module.f90:                            do k=1,size(friction_regions(m)%depths) - 1
geolib_source/friction_module.f90:                                if (friction_regions(m)%depths(k+1) <= aux(1,i,j) - sea_level &
geolib_source/friction_module.f90:                                    .and. friction_regions(m)%depths(k) > aux(1,i,j) - sea_level) then
geolib_source/friction_module.f90:        inner = (i .gt. mint .and. i .lt. mx-mint+1) .and. &
geolib_source/friction_module.f90:                (j .gt. mint .and. j .lt. my-mint+1)
geolib_source/friction_module.f90:        outer = (i .lt. 1-nghost) .or. (i .gt. mx+nghost) .or. &
geolib_source/friction_module.f90:                (j .lt. 1-nghost) .or. (j .gt. my+nghost)
geolib_source/friction_module.f90:    !  read_friction_file - Reads an input file containing info on friction
geolib_source/friction_module.f90:                file%upper(1) = file%lower(1) + file%dx(1) * (file%num_cells(1) - 1)
geolib_source/friction_module.f90:                file%upper(2) = file%lower(2) + file%dx(2) * (file%num_cells(2) - 1)
geolib_source/friction_module.f90:!                             read(iunit,*) (auxinit((j-1)*mx + i),i=1,mx)
geolib_source/friction_module.f90:!                                 if (auxinit((j-1)*mx + i) == no_data_value) then
geolib_source/friction_module.f90:!                                     auxinit((j-1)*mx + i) = missing_value
geolib_source/topo_update.f90:          kdtopo1(m) = int(floor((t-t0dtopo(m))/dtdtopo(m)))+1
geolib_source/topo_update.f90:          kdtopo2(m) = int(ceiling((t-t0dtopo(m))/dtdtopo(m)))+1
geolib_source/topo_update.f90:          tdtopo1(m) = t0dtopo(m)+ dtdtopo(m)*real(kdtopo1(m)-1,kind=8) ! <= t
geolib_source/topo_update.f90:          tdtopo2(m) = t0dtopo(m)+ dtdtopo(m)*real(kdtopo2(m)-1,kind=8) ! >= t
geolib_source/topo_update.f90:          taudtopo(m) = 1.d0-max(0.d0,((t-tdtopo1(m))/dtdtopo(m)))
geolib_source/topo_update.f90:      index0_dtopowork1(m) = i0dtopo(m) + (kdtopo1(m)-1)*mxdtopo(m)*mydtopo(m)
geolib_source/topo_update.f90:      index0_dtopowork2(m) = i0dtopo(m) + (kdtopo2(m)-1)*mxdtopo(m)*mydtopo(m)
geolib_source/topo_update.f90:   !do i= mtopofiles - num_dtopo + 1, mtopofiles !topofile
geolib_source/topo_update.f90:   !   m = i - mtopofiles + num_dtopo !corresponding dtopofile
geolib_source/topo_update.f90:   !   topowork(i0topo(i):i0topo(i) + mtopo(i)-1) = &
geolib_source/topo_update.f90:   !            topo0work(i0topo0(i):i0topo0(i) + mtopo(i)-1) &!initial topo
geolib_source/topo_update.f90:   !            + taudtopo(m)*dtopowork(index0_dtopowork1(m):index0_dtopowork1(m) + mtopo(i)-1) &
geolib_source/topo_update.f90:   !            + (1.0-taudtopo(m))*dtopowork(index0_dtopowork2(m):index0_dtopowork2(m) + mtopo(i)-1)
geolib_source/topo_update.f90:      !set time-stamp
geolib_source/topo_update.f90:   !set non-dtopo associated topofiles
geolib_source/topo_update.f90:         y = yhitopo(mt) - real(j-1,kind=8)*dytopo(mt)
geolib_source/topo_update.f90:            ij = i0topo(mt) + (j-1)*mxtopo(mt) + i -1
geolib_source/topo_update.f90:            ij0 = i0topo0(mt) + (j-1)*mxtopo(mt) + i -1
geolib_source/topo_update.f90:            x = xlowtopo(mt) +  real(i-1,kind=8)*dxtopo(mt)
geolib_source/topo_update.f90:               idtopo1 = int(floor((x-xlowdtopo(m))/dxdtopo(m)))+1
geolib_source/topo_update.f90:               idtopo1 = max(1, min(mxdtopo(m)-1, idtopo1))
geolib_source/topo_update.f90:               jdtopo1 = int(floor((yhidtopo(m)-y)/dydtopo(m))) + 1
geolib_source/topo_update.f90:               jdtopo1 = max(1, min(mydtopo(m)-1, jdtopo1))
geolib_source/topo_update.f90:               ijll = index0_dtopowork1(m) + (jdtopo2-1)*mxdtopo(m) + idtopo1 -1
geolib_source/topo_update.f90:               ijlr = index0_dtopowork1(m) + (jdtopo2-1)*mxdtopo(m) + idtopo2 -1
geolib_source/topo_update.f90:               ijul = index0_dtopowork1(m) + (jdtopo1-1)*mxdtopo(m) + idtopo1 -1
geolib_source/topo_update.f90:               ijur = index0_dtopowork1(m) + (jdtopo1-1)*mxdtopo(m) + idtopo2 -1
geolib_source/topo_update.f90:               xl = xlowdtopo(m) + real(idtopo1-1,kind=8)*dxdtopo(m)
geolib_source/topo_update.f90:               yu = yhidtopo(m) - real(jdtopo1-1,kind=8)*dydtopo(m)
geolib_source/topo_update.f90:               yl = yu - dydtopo(m)
geolib_source/topo_update.f90:               dz1 = zll*(xr-x)*(yu-y) + zlr*(x-xl)*(yu-y) + zul*(xr-x)*(y-yl) + zur*(x-xl)*(y-yl)
geolib_source/topo_update.f90:               ijll = index0_dtopowork2(m) + (jdtopo2-1)*mxdtopo(m) + idtopo1 -1
geolib_source/topo_update.f90:               ijlr = index0_dtopowork2(m) + (jdtopo2-1)*mxdtopo(m) + idtopo2 -1
geolib_source/topo_update.f90:               ijul = index0_dtopowork2(m) + (jdtopo1-1)*mxdtopo(m) + idtopo1 -1
geolib_source/topo_update.f90:               ijur = index0_dtopowork2(m) + (jdtopo1-1)*mxdtopo(m) + idtopo2 -1
geolib_source/topo_update.f90:               dz2 = zll*(xr-x)*(yu-y) + zlr*(x-xl)*(yu-y) + zul*(xr-x)*(y-yl) + zur*(x-xl)*(y-yl)
geolib_source/topo_update.f90:               dz12 = taudtopo(m)*dz1 + (1.0-taudtopo(m))*dz2
hydrograph/hydrograh_module.f90:            write(GEO_PARM_UNIT,*)'--------------------------------------------'
hydrograph/hydrograh_module.f90:            write(GEO_PARM_UNIT,*) '------------------------------'
hydrograph/hydrograh_module.f90:            do i = 1,size(time)-1
hydrograph/hydrograh_module.f90:                    interpolated_value = inflow(i) + (inflow(i+1) - inflow(i)) / (time(i+1) - time(i)) * (t - time(i))
hydrograph/hydrograh_module.f90:        tol = 1.0e-6    ! tolerance for convergence
hydrograph/hydrograh_module.f90:                fxn = q0(2)/q0(1) - 2*sqrt(grav*q0(1)) - u1 + 2*sqrt(grav*q1(1))
hydrograph/hydrograh_module.f90:                dfxn = -q0(2)/(q0(1)**2) - sqrt(grav/q0(1)) !dfunc_h0()
hydrograph/hydrograh_module.f90:                q0(1) = q0(1) - fxn/dfxn
hydrograph/hydrograh_module.f90:            write(*,*) 'Newton-Raphson did not converge'
hydrograph/hydrograh_module.f90:                    fxn = q0(2)/q0(1) - 2*sqrt(grav*q0(1)) - u1 + 2*sqrt(grav*q1(1))
hydrograph/hydrograh_module.f90:                    q0(2) = q0(2) - fxn/dfxn
hydrograph/hydrograh_module.f90:                write(*,*) 'Newton-Raphson did not converge'
hydrograph/hydrograh_module.f90:        tol = 1.0e-6    ! tolerance for convergence
hydrograph/hydrograh_module.f90:                fxn = q0(2)/q0(1) - (q0(1) - q1(1))*sqrt((grav/2.0d0)*(1.0d0/q0(1) + 1.0d0/q1(1)))
hydrograph/hydrograh_module.f90:                dfxn = -q0(2)/(q0(1)**2) - num/sqrt(2.0d0) + grav*(q0(1) - q1(1))/deno
hydrograph/hydrograh_module.f90:                q0(1) = q0(1) - fxn/dfxn
hydrograph/hydrograh_module.f90:            write(*,*) 'Newton-Raphson did not converge'
hydrograph/hydrograh_module.f90:                    fxn = q0(2)/q0(1) - 2*sqrt(grav*q0(1)) - u1 + 2*sqrt(grav*q1(1))
hydrograph/hydrograh_module.f90:                    q0(2) = q0(2) - fxn/dfxn
hydrograph/hydrograh_module.f90:                write(*,*) 'Newton-Raphson did not converge'
Makefile.am:# -*- Makefile -*-
Makefile.am:FCLAW_GEOCLAW_CPPFLAGS = -I@top_srcdir@/src/solvers/fc2d_geoclaw
README:# ------------------------------------------
README:# New York (Courant visit); 4/21-4/24 (2016)
README:# ------------------------------------------
README:   -- geolib_source : all files from clawpack/geoclaw/src/2d/shallow
README:   -- amrlib_source : some files from clawpack/amrclaw/src/2d;
README:   -- fortran_source : additional files needed to interface with
README:   -- Copy Riemann solvers (rpn2_geoclaw.f90, rpt2_geoclaw.f90,
README:4.  Change names of Riemann solvers (rpn2 -> geoclaw_rpn2; rpt2 -> geoclaw_rpt2)
README:5.  geoclaw_step2.f : Added code to handle cubed-sphere (three corners)
README:# -----------------
README:# -----------------
riemann_source/rpt2_geoclaw.f:!-----------------------last modified 1/10/05----------------------
riemann_source/rpt2_geoclaw.f:      double precision  ql(meqn,1-mbc:maxm+mbc)
riemann_source/rpt2_geoclaw.f:      double precision  qr(meqn,1-mbc:maxm+mbc)
riemann_source/rpt2_geoclaw.f:      double precision  asdq(meqn,1-mbc:maxm+mbc)
riemann_source/rpt2_geoclaw.f:      double precision  bmasdq(meqn,1-mbc:maxm+mbc)
riemann_source/rpt2_geoclaw.f:      double precision  bpasdq(meqn,1-mbc:maxm+mbc)
riemann_source/rpt2_geoclaw.f:      double precision  aux1(maux,1-mbc:maxm+mbc)
riemann_source/rpt2_geoclaw.f:      double precision  aux2(maux,1-mbc:maxm+mbc)
riemann_source/rpt2_geoclaw.f:      double precision  aux3(maux,1-mbc:maxm+mbc)
riemann_source/rpt2_geoclaw.f:      do i=2-mbc,mx+mbc
riemann_source/rpt2_geoclaw.f:         hl=qr(1,i-1)
riemann_source/rpt2_geoclaw.f:         hul=qr(mu,i-1)
riemann_source/rpt2_geoclaw.f:         hvl=qr(mv,i-1)
riemann_source/rpt2_geoclaw.f:            eta = qr(1,i-1)  + aux2(1,i-1)
riemann_source/rpt2_geoclaw.f:            topo1 = aux1(1,i-1)
riemann_source/rpt2_geoclaw.f:            topo3 = aux3(1,i-1)
riemann_source/rpt2_geoclaw.f:c            s1 = vl-sqrt(g*hl)
riemann_source/rpt2_geoclaw.f:c            s1 = vr-sqrt(g*hr)
riemann_source/rpt2_geoclaw.f:               dxdcp = earth_radius*cos(aux3(3,i-1))*deg2rad
riemann_source/rpt2_geoclaw.f:               dxdcm = earth_radius*cos(aux1(3,i-1))*deg2rad
riemann_source/rpt2_geoclaw.f:            roe1=vhat-dsqrt(g*hhat)
riemann_source/rpt2_geoclaw.f:            s1l=vl-dsqrt(g*hl)
riemann_source/rpt2_geoclaw.f:         beta(1) = (s3*delf1/(s3-s1))-(delf3/(s3-s1))
riemann_source/rpt2_geoclaw.f:         beta(2) = -s2*delf1 + delf2
riemann_source/rpt2_geoclaw.f:         beta(3) = (delf3/(s3-s1))-(s1*delf1/(s3-s1))
riemann_source/rpt2_geoclaw.f:c=====================Set-up eigenvectors===================================
riemann_source/geoclaw_riemann_utils.f:c-----------------------------------------------------------------------
riemann_source/geoclaw_riemann_utils.f:      ! This solver is described in J. Comput. Phys. (6): 3089-3113, March 2008
riemann_source/geoclaw_riemann_utils.f:      delh = hR-hL
riemann_source/geoclaw_riemann_utils.f:      delhu = huR-huL
riemann_source/geoclaw_riemann_utils.f:      delphi = phiR-phiL
riemann_source/geoclaw_riemann_utils.f:      delb = bR-bL
riemann_source/geoclaw_riemann_utils.f:      lambda(2) = 0.d0  ! ### Fix to avoid uninitialized value in loop on mw -- Correct?? ###
riemann_source/geoclaw_riemann_utils.f:      hstarHLL = max((huL-huR+sE2*hR-sE1*hL)/(sE2-sE1),0.d0) ! middle state in an HLL solve
riemann_source/geoclaw_riemann_utils.f:c     !determine the middle entropy corrector wave------------------------
riemann_source/geoclaw_riemann_utils.f:         sdelta=lambda(3)-lambda(1)
riemann_source/geoclaw_riemann_utils.f:            rare1st=3.d0*(sqrt(g*hL)-sqrt(g*hm))
riemann_source/geoclaw_riemann_utils.f:            rare2st=3.d0*(sqrt(g*hR)-sqrt(g*hm))
riemann_source/geoclaw_riemann_utils.f:c     ## Is this correct 2-wave when rarecorrector == .true. ??
riemann_source/geoclaw_riemann_utils.f:c     !---------------------------------------------------
riemann_source/geoclaw_riemann_utils.f:c     !determine the steady state wave -------------------
riemann_source/geoclaw_riemann_utils.f:      criticaltol = 1.d-6
riemann_source/geoclaw_riemann_utils.f:      deldelh = -delb
riemann_source/geoclaw_riemann_utils.f:      deldelphi = -g*0.5d0*(hR+hL)*delb
riemann_source/geoclaw_riemann_utils.f:      convergencetol=1.d-6
riemann_source/geoclaw_riemann_utils.f:         s1s2bar = 0.25d0*(uLstar+uRstar)**2 - g*hbar
riemann_source/geoclaw_riemann_utils.f:         s1s2tilde= max(0.d0,uLstar*uRstar) - g*hbar
riemann_source/geoclaw_riemann_utils.f:         if ((uL-sqrt(g*hL))*(uR-sqrt(g*hR)).lt.0.d0) sonic=.true.
riemann_source/geoclaw_riemann_utils.f:            deldelh =  -delb
riemann_source/geoclaw_riemann_utils.f:         if (sE1.lt.-criticaltol.and.sE2.gt.criticaltol) then
riemann_source/geoclaw_riemann_utils.f:            deldelh = min(deldelh,hstarHLL*(sE2-sE1)/sE2)
riemann_source/geoclaw_riemann_utils.f:            deldelh = max(deldelh,hstarHLL*(sE2-sE1)/sE1)
riemann_source/geoclaw_riemann_utils.f:            deldelh = min(deldelh,hstarHLL*(sE2-sE1)/sE1)
riemann_source/geoclaw_riemann_utils.f:            deldelh = max(deldelh,-hL)
riemann_source/geoclaw_riemann_utils.f:         elseif (sE2.le.-criticaltol) then
riemann_source/geoclaw_riemann_utils.f:            deldelh = max(deldelh,hstarHLL*(sE2-sE1)/sE2)
riemann_source/geoclaw_riemann_utils.f:            deldelphi = -g*hbar*delb
riemann_source/geoclaw_riemann_utils.f:            deldelphi = -delb*g*hbar*s1s2tilde/s1s2bar
riemann_source/geoclaw_riemann_utils.f:         deldelphi=min(deldelphi,g*max(-hLstar*delb,-hRstar*delb))
riemann_source/geoclaw_riemann_utils.f:         deldelphi=max(deldelphi,g*min(-hLstar*delb,-hRstar*delb))
riemann_source/geoclaw_riemann_utils.f:         del(1)=delh-deldelh
riemann_source/geoclaw_riemann_utils.f:         del(3)=delphi-deldelphi
riemann_source/geoclaw_riemann_utils.f:         det1=r(1,1)*(r(2,2)*r(3,3)-r(2,3)*r(3,2))
riemann_source/geoclaw_riemann_utils.f:         det2=r(1,2)*(r(2,1)*r(3,3)-r(2,3)*r(3,1))
riemann_source/geoclaw_riemann_utils.f:         det3=r(1,3)*(r(2,1)*r(3,2)-r(2,2)*r(3,1))
riemann_source/geoclaw_riemann_utils.f:         determinant=det1-det2+det3
riemann_source/geoclaw_riemann_utils.f:            det1=A(1,1)*(A(2,2)*A(3,3)-A(2,3)*A(3,2))
riemann_source/geoclaw_riemann_utils.f:            det2=A(1,2)*(A(2,1)*A(3,3)-A(2,3)*A(3,1))
riemann_source/geoclaw_riemann_utils.f:            det3=A(1,3)*(A(2,1)*A(3,2)-A(2,2)*A(3,1))
riemann_source/geoclaw_riemann_utils.f:            beta(k)=(det1-det2+det3)/determinant
riemann_source/geoclaw_riemann_utils.f:         if (abs(del(1)**2+del(3)**2-delnorm).lt.convergencetol) exit
riemann_source/geoclaw_riemann_utils.f:         do mw=mwaves,1,-1
riemann_source/geoclaw_riemann_utils.f:               hRstar= hRstar - beta(mw)*r(1,mw)
riemann_source/geoclaw_riemann_utils.f:               huRstar= huRstar - beta(mw)*r(2,mw)
riemann_source/geoclaw_riemann_utils.f:      fw(3,2)= hR*uR*vR - hL*uL*vL - fw(3,1)- fw(3,3)
riemann_source/geoclaw_riemann_utils.f:      end !subroutine riemann_aug_JCP-------------------------------------------------
riemann_source/geoclaw_riemann_utils.f:c-----------------------------------------------------------------------
riemann_source/geoclaw_riemann_utils.f:      delh = hR-hL
riemann_source/geoclaw_riemann_utils.f:      delhu = huR-huL
riemann_source/geoclaw_riemann_utils.f:      delphi = phiR-phiL
riemann_source/geoclaw_riemann_utils.f:      delb = bR-bL
riemann_source/geoclaw_riemann_utils.f:      convergencetol= 1.d-16
riemann_source/geoclaw_riemann_utils.f:      criticaltol = 1.d-99
riemann_source/geoclaw_riemann_utils.f:      deldelh = -delb
riemann_source/geoclaw_riemann_utils.f:      deldelphi = -g*0.5d0*(hR+hL)*delb
riemann_source/geoclaw_riemann_utils.f:         hstarHLL = max((huL-huR+sE2*hR-sE1*hL)/(sE2-sE1),0.d0) ! middle state in an HLL solve
riemann_source/geoclaw_riemann_utils.f:            s1s2bar = 0.25d0*(uLstar+uRstar)**2 - g*hbar
riemann_source/geoclaw_riemann_utils.f:            s1s2tilde= max(0.d0,uLstar*uRstar) - g*hbar
riemann_source/geoclaw_riemann_utils.f:               deldelh =  -delb
riemann_source/geoclaw_riemann_utils.f:            if (sE1.lt.-criticaltol.and.sE2.gt.criticaltol) then
riemann_source/geoclaw_riemann_utils.f:               deldelh = min(deldelh,hstarHLL*(sE2-sE1)/sE2)
riemann_source/geoclaw_riemann_utils.f:               deldelh = max(deldelh,hstarHLL*(sE2-sE1)/sE1)
riemann_source/geoclaw_riemann_utils.f:               deldelh = min(deldelh,hstarHLL*(sE2-sE1)/sE1)
riemann_source/geoclaw_riemann_utils.f:               deldelh = max(deldelh,-hL)
riemann_source/geoclaw_riemann_utils.f:            elseif (sE2.le.-criticaltol) then
riemann_source/geoclaw_riemann_utils.f:               deldelh = max(deldelh,hstarHLL*(sE2-sE1)/sE2)
riemann_source/geoclaw_riemann_utils.f:               deldelphi = -g*hbar*delb
riemann_source/geoclaw_riemann_utils.f:               deldelphi = -delb*g*hbar*s1s2tilde/s1s2bar
riemann_source/geoclaw_riemann_utils.f:            deldelphi=min(deldelphi,g*max(-hLstar*delb,-hRstar*delb))
riemann_source/geoclaw_riemann_utils.f:            deldelphi=max(deldelphi,g*min(-hLstar*delb,-hRstar*delb))
riemann_source/geoclaw_riemann_utils.f:!---------determine fwaves ------------------------------------------
riemann_source/geoclaw_riemann_utils.f:            delhdecomp = delh-deldelh
riemann_source/geoclaw_riemann_utils.f:            delalpha1 = (sE2*delhdecomp - delhu)/(sE2-sE1)-alpha1
riemann_source/geoclaw_riemann_utils.f:            delalpha2 = (delhu - sE1*delhdecomp)/(sE2-sE1)-alpha2
riemann_source/geoclaw_riemann_utils.f:            delphidecomp = delphi - deldelphi
riemann_source/geoclaw_riemann_utils.f:            beta1 = (sE2*delhu - delphidecomp)/(sE2-sE1)
riemann_source/geoclaw_riemann_utils.f:            beta2 = (delphidecomp - sE1*delhu)/(sE2-sE1)
riemann_source/geoclaw_riemann_utils.f:               hRstar=hR-alpha2
riemann_source/geoclaw_riemann_utils.f:               hRstar=hR - alpha1 - alpha2
riemann_source/geoclaw_riemann_utils.f:      delhdecomp = delh - deldelh
riemann_source/geoclaw_riemann_utils.f:      delphidecomp = delphi - deldelphi
riemann_source/geoclaw_riemann_utils.f:      alpha1 = (sE2*delhdecomp - delhu)/(sE2-sE1)
riemann_source/geoclaw_riemann_utils.f:      alpha2 = (delhu - sE1*delhdecomp)/(sE2-sE1)
riemann_source/geoclaw_riemann_utils.f:      beta1 = (sE2*delhu - delphidecomp)/(sE2-sE1)
riemann_source/geoclaw_riemann_utils.f:      beta2 = (delphidecomp - sE1*delhu)/(sE2-sE1)
riemann_source/geoclaw_riemann_utils.f:      fw(3,2) = hR*uR*vR - hL*uL*vL -fw(3,1)-fw(3,3)
riemann_source/geoclaw_riemann_utils.f:      end subroutine !-------------------------------------------------
riemann_source/geoclaw_riemann_utils.f:c-----------------------------------------------------------------------
riemann_source/geoclaw_riemann_utils.f:      ! flux - source is decomposed.
riemann_source/geoclaw_riemann_utils.f:      delh = hR-hL
riemann_source/geoclaw_riemann_utils.f:      delhu = huR-huL
riemann_source/geoclaw_riemann_utils.f:      delphi = phiR-phiL
riemann_source/geoclaw_riemann_utils.f:      delb = bR-bL
riemann_source/geoclaw_riemann_utils.f:      deldelphi = -g*0.5d0*(hR+hL)*delb
riemann_source/geoclaw_riemann_utils.f:      delphidecomp = delphi - deldelphi
riemann_source/geoclaw_riemann_utils.f:      beta1 = (s2*delhu - delphidecomp)/(s2-s1)
riemann_source/geoclaw_riemann_utils.f:      beta2 = (delphidecomp - s1*delhu)/(s2-s1)
riemann_source/geoclaw_riemann_utils.f:      fw(3,2) = hR*uR*vR - hL*uL*vL -fw(3,1)-fw(3,3)
riemann_source/geoclaw_riemann_utils.f:      end !subroutine -------------------------------------------------
riemann_source/geoclaw_riemann_utils.f:      !determine the Riemann structure (wave-type in each family)
riemann_source/geoclaw_riemann_utils.f:      delu=uR-uL
riemann_source/geoclaw_riemann_utils.f:         s1m=uR+uL-2.d0*sqrt(g*hR)+2.d0*sqrt(g*hL)
riemann_source/geoclaw_riemann_utils.f:         s2m=uR+uL-2.d0*sqrt(g*hR)+2.d0*sqrt(g*hL)
riemann_source/geoclaw_riemann_utils.f:         F_min= delu+2.d0*(sqrt(g*h_min)-sqrt(g*h_max))
riemann_source/geoclaw_riemann_utils.f:     &         (h_max-h_min)*(sqrt(.5d0*g*(h_max+h_min)/(h_max*h_min)))
riemann_source/geoclaw_riemann_utils.f:         if (F_min.gt.0.d0) then !2-rarefactions
riemann_source/geoclaw_riemann_utils.f:     &               max(0.d0,-delu+2.d0*(sqrt(g*hL)+sqrt(g*hR)))**2
riemann_source/geoclaw_riemann_utils.f:            um=sign(1.d0,hm)*(uL+2.d0*(sqrt(g*hL)-sqrt(g*hm)))
riemann_source/geoclaw_riemann_utils.f:            s1m=uL+2.d0*sqrt(g*hL)-3.d0*sqrt(g*hm)
riemann_source/geoclaw_riemann_utils.f:            s2m=uR-2.d0*sqrt(g*hR)+3.d0*sqrt(g*hm)
riemann_source/geoclaw_riemann_utils.f:               F0=delu+(h0-hL)*gL + (h0-hR)*gR
riemann_source/geoclaw_riemann_utils.f:               dfdh=gL-g*(h0-hL)/(4.d0*(h0**2)*gL)+
riemann_source/geoclaw_riemann_utils.f:     &                   gR-g*(h0-hR)/(4.d0*(h0**2)*gR)
riemann_source/geoclaw_riemann_utils.f:               h0=(sqrt(h0)-F0/slope)**2
riemann_source/geoclaw_riemann_utils.f:               u1m=uL-(hm-hL)*sqrt((.5d0*g)*(1/hm + 1/hL))
riemann_source/geoclaw_riemann_utils.f:               u2m=uR+(hm-hR)*sqrt((.5d0*g)*(1/hm + 1/hR))
riemann_source/geoclaw_riemann_utils.f:               s1m=u1m-sqrt(g*hm)
riemann_source/geoclaw_riemann_utils.f:               F0=delu + 2.d0*(sqrt(g*h0)-sqrt(g*h_max))
riemann_source/geoclaw_riemann_utils.f:     &                  + (h0-h_min)*sqrt(.5d0*g*(1/h0+1/h_min))
riemann_source/geoclaw_riemann_utils.f:               slope=(F_max-F0)/(h_max-h_min)
riemann_source/geoclaw_riemann_utils.f:               h0=h0-F0/slope
riemann_source/geoclaw_riemann_utils.f:               um=uL+2.d0*sqrt(g*hL)-2.d0*sqrt(g*hm)
riemann_source/geoclaw_riemann_utils.f:               s1m=uL+2.d0*sqrt(g*hL)-3.d0*sqrt(g*hm)
riemann_source/geoclaw_riemann_utils.f:               s2m=uL+2.d0*sqrt(g*hL)-sqrt(g*hm)
riemann_source/geoclaw_riemann_utils.f:               s2m=uR-2.d0*sqrt(g*hR)+3.d0*sqrt(g*hm)
riemann_source/geoclaw_riemann_utils.f:               s1m=uR-2.d0*sqrt(g*hR)+sqrt(g*hm)
riemann_source/geoclaw_riemann_utils.f:               um=uR-2.d0*sqrt(g*hR)+2.d0*sqrt(g*hm)
riemann_source/geoclaw_riemann_utils.f:      end ! subroutine riemanntype----------------------------------------------------------------
riemann_source/rpn2_geoclaw.f:c     #        (hu)_t + (hu^2 + 0.5gh^2)_x + (huv)_y = -ghb_x      #
riemann_source/rpn2_geoclaw.f:c     #        (hv)_t + (huv)_x + (hv^2 + 0.5gh^2)_y = -ghb_y      #
riemann_source/rpn2_geoclaw.f:c This data is along a slice in the x-direction if ixy=1
riemann_source/rpn2_geoclaw.f:c     or the y-direction if ixy=2.
riemann_source/rpn2_geoclaw.f:c  Note that the i'th Riemann problem has left state qr(i-1,:)
riemann_source/rpn2_geoclaw.f:      double precision  fwave(meqn, mwaves, 1-mbc:maxm+mbc)
riemann_source/rpn2_geoclaw.f:      double precision  s(mwaves, 1-mbc:maxm+mbc)
riemann_source/rpn2_geoclaw.f:      double precision  ql(meqn, 1-mbc:maxm+mbc)
riemann_source/rpn2_geoclaw.f:      double precision  qr(meqn, 1-mbc:maxm+mbc)
riemann_source/rpn2_geoclaw.f:      double precision  apdq(meqn,1-mbc:maxm+mbc)
riemann_source/rpn2_geoclaw.f:      double precision  amdq(meqn,1-mbc:maxm+mbc)
riemann_source/rpn2_geoclaw.f:      double precision  auxl(maux,1-mbc:maxm+mbc)
riemann_source/rpn2_geoclaw.f:      double precision  auxr(maux,1-mbc:maxm+mbc)
riemann_source/rpn2_geoclaw.f:      do i=2-mbc,mx+mbc
riemann_source/rpn2_geoclaw.f:!-----------------------Initializing-----------------------------------
riemann_source/rpn2_geoclaw.f:         if((qr(1,i-1).lt.0.d0).or.(ql(1,i) .lt. 0.d0)) then
riemann_source/rpn2_geoclaw.f:            write(*,*) 'Negative input: hl,hr,i=',qr(1,i-1),ql(1,i),i
riemann_source/rpn2_geoclaw.f:         if (qr(1,i-1).lt.0.d0) then
riemann_source/rpn2_geoclaw.f:               qr(1,i-1)=0.d0
riemann_source/rpn2_geoclaw.f:               qr(2,i-1)=0.d0
riemann_source/rpn2_geoclaw.f:               qr(3,i-1)=0.d0
riemann_source/rpn2_geoclaw.f:         if (qr(1,i-1) <= drytol .and. ql(1,i) <= drytol) then
riemann_source/rpn2_geoclaw.f:         hL = qr(1,i-1)
riemann_source/rpn2_geoclaw.f:         huL = qr(mu,i-1)
riemann_source/rpn2_geoclaw.f:         bL = auxr(1,i-1)
riemann_source/rpn2_geoclaw.f:         hvL=qr(nv,i-1)
riemann_source/rpn2_geoclaw.f:            call riemanntype(hL,hL,uL,-uL,hstar,s1m,s2m,
riemann_source/rpn2_geoclaw.f:               huR=-huL
riemann_source/rpn2_geoclaw.f:               uR=-uL
riemann_source/rpn2_geoclaw.f:            call riemanntype(hR,hR,-uR,uR,hstar,s1m,s2m,
riemann_source/rpn2_geoclaw.f:               huL=-huR
riemann_source/rpn2_geoclaw.f:               uL=-uR
riemann_source/rpn2_geoclaw.f:         sL=uL-sqrt(g*hL) ! 1 wave speed of left state
riemann_source/rpn2_geoclaw.f:         sRoe1=uhat-chat ! Roe wave speed 1 wave
riemann_source/rpn2_geoclaw.f:         !--------------------end initializing...finally----------
riemann_source/rpn2_geoclaw.f:         do i=2-mbc,mx+mbc
riemann_source/rpn2_geoclaw.f:         do i=2-mbc,mx+mbc
riemann_source/rpn2_geoclaw.f:!--       do i=2-mbc,mx+mbc
riemann_source/rpn2_geoclaw.f:!--            do m=1,meqn
riemann_source/rpn2_geoclaw.f:!--                write(51,151) m,i,amdq(m,i),apdq(m,i)
riemann_source/rpn2_geoclaw.f:!--                write(51,152) fwave(m,1,i),fwave(m,2,i),fwave(m,3,i)
riemann_source/rpn2_geoclaw.f:!--151             format("++3 ampdq ",2i4,2e25.15)
riemann_source/rpn2_geoclaw.f:!--152             format("++3 fwave ",8x,3e25.15)
riemann_source/rpn2_geoclaw.f:!--            enddo
riemann_source/rpn2_geoclaw.f:!--        enddo
